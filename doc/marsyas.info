This is marsyas.info, produced by makeinfo version 4.8 from
marsyas.texi.

INFO-DIR-SECTION Audio
START-INFO-DIR-ENTRY
* Marsyas: (marsyas). Marsyas Analysis Retrieval and Synthesis for
Audio Signals
END-INFO-DIR-ENTRY

   Copyright 1998-2006 George Tzanetakis

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "Copying" and "GNU General Public License"
are included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: marsyas.info,  Node: Top,  Next: Introduction,  Up: (dir)

Marsyas Manual
**************

* Menu:

* Introduction::                History, related work, and goals.
* Installation::                Installation instructions for different operating systems.
* Tools::                       Various sample tools built using marsyas
components.
* Architecture::                Software architecture, concepts, and assembling new MarSystems.
* Programming::                 Writing new basic MarSystem blocks.
* Interoperability::            Using Marsyas with other projects.
* Future Work::                 Where Marsyas is going.
* Users and Projects::          Past and current users/projects.
* The Index::                   The Index.


File: marsyas.info,  Node: Introduction,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

MARSYAS (Music Analysis Retrieval and Synthesis for Audio Signals) is a
free software framework for audio analysis, synthesis and retrieval
written by George Tzanetakis. Please direct any questions/comments
about Marsyas to (gtzan@cs.uvic.ca).  

   The major underlying theme under the design of Marsyas has been to
provide an efficient and extensible framework for building audio
analysis (and synthesis) applications with specific emphasis on Music
Information Retrieval (MIR). A variety of building blocks for
performing common audio tasks are provided. Some representative
examples are: soundfile IO, audio IO, signal processing and machine
learning modules.  These blocks can be combined into data flow networks
that can be modified and controlled dynamically while they process data
in soft real-time.

   Another goal has been to accomodate two different types of users:
naive and expert (of course in many cases the same person can operate
in both modes). Naive users are able to construct networks of primitive
objects and experiment with them through the use of controls. They can
interact with the system through the use of graphical user interfaces
or high level scripts without actually having to compile any code.
Marsyas provides a high-level of control at runtime without sacrificing
performance. Expert users can create new primitive objects and create
more complex applications by writing code and compiling. These two
modes of operation will become clearer in the following sections of the
manual. As with any piece of software the holy grail is to provide
maximum automatic support for the tasks that can be automated while
retaining expressiveness and the ability to program complex systems for
the particular domain of interest.

   This framework has been created mainly to support George Tzanetakis's
research mainly in the emerging area of Music Information Retrieval
(MIR). Anyone who finds the framework useful is welcome to use it and
contribute to it. If you would like specific features to be developed
feel free to contact the author or support the project by donnating
money through the sourceforge page.

* Menu:

* History::
* Context and Related Work::
* About the documentation::


File: marsyas.info,  Node: History,  Next: Context and Related Work,  Up: Introduction

1.1 History
===========

Work on Marsyas started in 1998 during my second year of graduate
studies in Computer Science at Princeton University under the
supervision of Dr. Perry Cook.  The main motivation behind the design
and development of the toolkit was and still is to personally code the
majority of the tools I need for my research in order to have
understanding and control of how they work. Marsyas has been used for
every paper I have published since that time. I continued to add code
to Marsyas until 2000 when it was clear that certain major design
decisions needed to be revised.  That made me start a major
rewrite/redesign of the framework and that was the start of the first
"real"  Marsyas version which was numbered 0.1. Soon after Sourceforge
was used to host Marsyas. Version 0.1 is still widely used by a variety
of academic groups and industry around the world.

   In 2002 while being a PostDoctoral Fellow at Carnegie Mellon
University working with Roger Dannenberg I decided to start porting
algorithms from the Synthesis Toolkit (STK) by Perry Cook and Gary
Scavone into Marsyas.  This effort as well as many interesting
conversations with Roger made me rethink the design used by Marsyas.
The result was to move to a dataflow model of audio computation with
general matrices instead of 1-D arrays as data and an Open Sound
Control (OSC) inspired hierarchical messaging system used to control
the dataflow network. Marsyas 0.2 is now almost to the point of
supporting the full functionality of Marsyas 0.1. Hopefully the writing
of this manual will help users migrate from version 0.1. If you are a
user that has done work in 0.1 it should be relatively straightforward
to figure out how to recode your algorithms in version 0.2. Also if you
have code in 0.1 that you would like help porting in 0.2 I would be
more than happy to help - just drop me an email.


File: marsyas.info,  Node: Context and Related Work,  Next: About the documentation,  Prev: History,  Up: Introduction

1.2 Context and Related Work
============================

There is a lot of interesting related work and inspiration behind the
design of this framework. As the goal of this introduction is to
provide a quick overview of the system I will just briefly mention some
of the key ideas that strongly influenced the design of the system
without getting into details. Probably the most central inspiration has
been the huge legacy of computer music synthesis languages such as the
Music V family, Csound etc. More recent work that has been influential
to the design of the system has been the architecture of the Synthesis
Toolkit (STK) and the hierarchical control naming scheme of Open Sound
Control (OSC). Other influences include the use of Design Patterns for
creating the object oriented architecture of the system, kernel stream
architectures as well as data flow simulation software systems such as
SimuLink by Matlab and the FilterGraph by Microsoft.  Finally many of
the ideas of functional programming such as the clear separation of
mutable and immutable data and the use of composition to build
complicated systems have been another major source of inspiration.

   There is a plethora of programming languages, frameworks and
environments for the analysis and synthesis of audio signals. The
processing of audio signals requires extensive numerical calculations
over large amounts of data especially when real-time performance is
desired. Therefore efficiency has always been a major concern in the
design of audio analysis and synthesis systems. Dataflow programming is
based on the idea of expressing computation as a network of processing
nodes/components connected by a number of communication channels/arcs.
Computer Music is possibly one of the most successful application areas
for the dataflow programming paradigm. The origins of this idea can
possibly be traced to the physical re-wiring (patching) employed for
changing sound characteristics in early modular analog synthesizers.
From the pioneering work on unit generators in the Music N family of
language to currently popular visual programming environments such as
Max/Msp and Pure Data (PD), the idea of patching components to build
systems is familiar to most computer music practitioners.

   Expressing audio processing systems as dataflow networks has several
advantages. The programmer can provide a declarative specification of
what needs to be computed without having to worry about the low level
implementation details. The resulting code can be very efficient and
have low memory requirements as data just "flows"  through the network
without having complicated dependencies. In addition, dataflow
approaches are particularly suited for visual programming. One of the
initial motivation for dataflow ideas was the exploitation of parallel
hardware and therefore dataflow systems are particularly suited for
parallel and distributed computation.

   Despite these advantages, dataflow programming has not managed to
become part of mainstream programming and replace existing imperative,
object-oriented and functional languages. Some of the traditional
criticisms aimed at dataflow programming include: the difficulty of
expressing complicated control information, the restrictions on using
assignment and global state information, the difficulty of expressing
iteration and complicated data structures, and the challenge of
synchronization.

   There are two main ways that existing successful dataflow systems
overcome these limitations. The first is to embed dataflow ideas into
an existing programming language. This is called coarse-grained
dataflow in contrast to fine-grained dataflow where the entire
computation is expressed as a flow graph. With coarse-grained dataflow,
complicated data structures, iteration, and state information are
handled in the host language while using dataflow for structured
modularity. The second way is to work on a domain whose nature and
specific constraints are a good fit to a dataflow approach. For
example, audio and multimedia processing typically deals with
fixed-rate calculation of large buffers of numerical data.

   Computer music has been one of the most successful cases of dataflow
applications even though the academic dataflow community doesn't seem
to be particularly aware of this fact. Existing audio processing
dataflow frameworks have difficulty handling spectral and filterbank
data in an conceptually clear manner. Another problem is the
restriction of using fixed buffer sizes and therefore fixed audio and
control rates. Both of these limitations can be traced to the
restricted semantics of patching as well as the need to explicitly
specify connections. Implicit Patching the technique used in
Marsyas-0.2 is an attempt to overcome these problems while maintaining
the advantages of dataflow computation.


File: marsyas.info,  Node: About the documentation,  Prev: Context and Related Work,  Up: Introduction

1.3 About the documentation
===========================

In addition to this manual, there are example files included in the
Marsyas source tree.  Many of these files are also included in the
manual, but you may prefer to examine these files in your favorite text
editor with your own syntax highlighting.

   * `examples/': the simplest examples are here.  These files are
     provided only for learning; they have little purpose as actual
     programs.

   * `qt4GUIs/tutorial': a simple QT4/Marsyas program.  Just like the
     files in `examples/', it has little value as a standalone program.

   Once you are familiar with everything covered in this manual and
those examples, you should examine the source code:

   * `src/': the source code for real Marsyas executables.  These are
     real, working programs.  This means that they have poor comments,
     bad variable names, and are difficult to read.  :)

   * `marsyas/': the source code for MarSystems.  These are the basic
     building blocks of Marsyas, and are even more difficult to read.

1.3.1 Help!
-----------

The documentation for Marsyas is still a work in progress; we can use
all the help we can get.  Don't say "oh, I don't know enough"  or "I'm
not good at writing English."    The question is not "could anybody
create something better than my suggestion?"    - the question is "is
this better than nothing?"    Remember the most important thing about
documentation:

     Documentation is like sex: when it is good, it is very, very good;
     and when it is bad, it is better than nothing.   (Dick Brandon)

Manual
......

If you can add something to the docs, please send an email to
`<marsyas-developers@lists.sourceforge.net>'.  A formal patch for the
texidoc is not required; we can take care of the technical details.
Here is an example of a perfect documentation suggestion:


To: marsyas-developers@lists.sourceforge.net
From: helpful-user@example.net
Subject: doc addition

In 4.2.1 Implicit patching vs. explicit patching, please add
----
It could be helpful to think of this like blah blah blah.
----
to the second paragraph.

Examples
........

Small, easy-to-understand examples are also great.  If you have some
source code that illustrates something, we can add it to `examples/'.
You don't have to write any English at all!


File: marsyas.info,  Node: Installation,  Next: Tools,  Prev: Introduction,  Up: Top

2 Installation
**************

* Menu:

* Download::
* Linux Installation::
* Mac OSX Installation::
* Windows (cygwin)::
* Windows (Visual Studio)::
* Configure Options::
* Structure of distribution::


File: marsyas.info,  Node: Download,  Next: Linux Installation,  Up: Installation

2.1 Download
============

2.1.1 Stable(-ish) Version
--------------------------

(Important Note: Marsyas does not use CVS and therefore the CVS
repository is out of date)

   Marsyas is hosted at SourceForge:

   http://marsyas.sourceforge.net/

   http://www.sourceforge.net/projects/marsyas

   Marsyas is open source software and is distributed as a tar ball
(something like marsyas-0.2.8.tar.gz).

   To extract the source file type:

     tar -zxvf marsyas-0.2.8.tar.gz

   This will create a subdirectory of the current directory called
marsyas-0.2.8 that contains all the source files needed for compiling
Marsyas.

2.1.2 Development Version
-------------------------

For the brave, the latest (possibly unstable!) version can be obtained
from the subversion repository stored at the sourceforge website.  To
check out a working copy do:

     svn co https://marsyas.svn.sourceforge.net/svnroot/marsyas/trunk marsyas-0.2.10

   You can replace marsyas-0.2.10 with any directory you want. The
version/release (version 0.2 release 10) is independently assigned from
subversion revisions and the latest can be found by checking the
sourceforge website.


File: marsyas.info,  Node: Linux Installation,  Next: Mac OSX Installation,  Prev: Download,  Up: Installation

2.2 Linux Installation
======================

Marsyas is mainly developed under Linux so installing under Linux is
quite straightforward and can be done using the standard autoconf
installation steps where > is whatever command-line prompt you have on
your system.

     ./configure
     make
     make install                 (as root user)

   By default Marsyas assumes that in Linux systems the ALSA sound
system and corresponding library and headers are installed.  Most new
Linux distribution are using ALSA.

   In addition there are several configure options that can be used to
enable/disable assertions, enable/disable debugging and include
optional packages such as support for reading mp3s.  *Note Configure
Options::.


File: marsyas.info,  Node: Mac OSX Installation,  Next: Windows (cygwin),  Prev: Linux Installation,  Up: Installation

2.3 Mac OSX Installation
========================

Installation under OS X is almost identical to Linux. The developer
tools are not installed by default so you will need to install them.
You can download XCode from the Apple Developer website. You can check
whether they are installed or not by checking that you can run gcc on a
terminal. Once gcc is installed then you can compile using the standard
autoconf procedure:

     ./configure
     make
     make install                         (as root user)

   In addition there are several configure options that can be used to
enable/disable assertions, enable/disable debugging and include
optional packages such as support for reading mp3s.  *Note Configure
Options::.


File: marsyas.info,  Node: Windows (cygwin),  Next: Windows (Visual Studio),  Prev: Mac OSX Installation,  Up: Installation

2.4 Windows (cygwin)
====================

Installation under Windows using the cygwin environment and gcc is
similar to Linux. The most recent version of Marsyas 0.2 use RtAudio
for audio playback under Cygwin. In order to compile RtAudio you will
need to have the DirectX SDk installed. The standard autoconf
installation procedure is used:

     ./configure
     make
     make install                         (as root user)

   In general, cygwin is not supported as well as Linux and OS X.


File: marsyas.info,  Node: Windows (Visual Studio),  Next: Configure Options,  Prev: Windows (cygwin),  Up: Installation

2.5 Windows (Visual Studio)
===========================

Installation under Visual Studio is still under construction and not
the full functionality of Marsyas 0.2 is supported.  Not all the
executables are supported. The main distribution contains two
subdirectories named marsyasVisualStudio2003, marsyasVisualStudio2005
that contain the necessary project solution files for compiling Marsyas
under Visual Studio. I have only tested this using Visual Studio 7.0
under Windows XP. Older version of Visual Studio might not work.
Support of the Windows port is not as good as Linux and OS X.


File: marsyas.info,  Node: Configure Options,  Next: Structure of distribution,  Prev: Windows (Visual Studio),  Up: Installation

2.6 Configure Options
=====================

Marsyas can be customized using various configuration options. In
autoconf systems (Linux, OSX, Cygwin) this done in the standard way
through the .configure script. For example to compile Marsyas with
assertions enabled and with mp3 support through libmad one would do:

     ./configure --enable-assert --enable-mad
     make
     make install                         (as root user)

The list of available options can be viewed by:

     ./configure --help

The following options are supported:

   * -enable-assert       turns assertions on (small performance
     penatly)

   * -enable-debug        compiles Marsyas in debug mode generating the
     necessary files for gdb (large performance penalty)

   * -enable-mad          enables support for reading mp3 files using
     libmad (which must be installed)

   * -enable-distributed  compiles code for distributed audio feature
     extraction (experimental)

   * -enable-readline     realine support for the Marsyas Scripting
     Language (msl)

   * -enable-oss          use the OSS sound system

   A set of optional graphical user interfaces written in QT 4 are also
included in the distribution in the qt4GUIs subdirectory.  If Qt4 is
installed on your machine and you have installed Marsyas on your system
you can compile the various GUIs by doing (replace MarPlayer with the
specific GUI you want compiled) (these GUIs have only been tested under
Linux and are currently under major development so use at your own
risk):

     cd qt4GUIs/MarPlayer
     qmake
     make

A frequent variation (if you don't have root priviledges) is to install
Marsyas in your home directory (replace /home/gtzan with the
appropriate path for your home directory).  This can be accomplished by
doing:

     ./configure --prefix=/home/gtzan
     make
     make install


File: marsyas.info,  Node: Structure of distribution,  Prev: Configure Options,  Up: Installation

2.7 Structure of distribution
=============================

Marsyas is primarily targeted to researchers and software developers
who want to build new systems and applications using existing building
blocks. Therefore familiarity with the directory structure of the
Marsyas distribution is important for any serious work with the
framework.

   The main marsyas directory consists of the following important files:

   * INSTALL, COPYING, THANKS, README, AUTHORS, TODO: text files with
     important information.

   * ChangeLog: the change log is not maintained as consistently as it
     should be but it still provides useful information about the
     evolution of the software.

   * configure.in, Makefile.am: the main files edited by the
     user/programmer that are required for the autotools. You will only
     need to edit these if you are adding new subdirectories or
     configuration options to the distribution.

In addition there are the following subdirectories:

   * marsyas: the main directory containing all the important source
     code of Marsyas. The source files in this subdirectory are
     compiled into a static library that other programs can use to
     access Marsyas functionality.

   * src: this subdirectory contains several sample executables that do
     various interesting things using the Marsyas software framework.
     Some of them are intended to be used as actual research tools
     others are more demonstration.  All new Marsyas users should
     browse at least some of the source code here.

   * doc: contains both the user manual (which you are currently
     reading) as well as the source code documentation that is
     generated using doxygen. To regenerate the manual in pdf or html
     type (in the doc subdirectory)

          make pdf
          make html

   * qt4GUIs: provides GUI interfaces using QT4. These will not work
     with earlier versions of QT. You must have QT4 installed in order
     to use or compile these applications. A README file is supplied
     with each one that has instructions on how to compile and run it.

   * config: configuration files used by autotools.

   * distributed: Experimental Marsyas classes for distributed
     processing.

   * marsyasMATLAB: User MATLAB scripts (mfiles).

   * marsyasVisualStudio2003: Project and Solution files for Visual
     Studio 2003

   * marsyasVisualStudio2005: Project and Solution files for Visual
     Studio 2005



File: marsyas.info,  Node: Tools,  Next: Architecture,  Prev: Installation,  Up: Top

3 Tools
*******

The main goal of Marsyas is to provide an extensible framework that can
be used to quickly design and experiment with audio analysis and
synthesis applications.  The tools provided with the distribution,
although useful, are only representative examples of what can be
achieved using the provided components.  Marsyas is an extensible
framework for building applications, so the primary purpose of these
examples is to provide source code of working applications.

* Menu:

* Collections and input files::
* Simple Soundfile Interaction::
* Feature Extraction::
* Synthesis::
* Marsystem Interaction::


File: marsyas.info,  Node: Collections and input files,  Next: Simple Soundfile Interaction,  Up: Tools

3.1 Collections and input files
===============================

Many Marsyas tools can operate on individual soundfiles or collections
of soundfiles.  A collection is a simple text file which contain lists
of soundfiles.

* Menu:

* Creating collections manually::
* mkcollection::


File: marsyas.info,  Node: Creating collections manually,  Next: mkcollection,  Up: Collections and input files

3.1.1 Creating collections manually
-----------------------------------

A simple way to create a collection is the unix ls command.  For
example:

     ls /home/gtzan/data/sound/reggae/*.wav > reggae.mf

`reggae.mf' will look like this:

     /home/gtzan/data/sound/reggae/foo.wav
     /home/gtzan/data/sound/reggae/bar.wav

   Any text editor can be used to create collection files. The only
constraint is that the name of the collections file must have a `.mf'
extension such as `reggae.mf'.   In addition, any line starting with
the `#' character is ignored.  For Windows Visual Studio, change the
slash character separating directories appropriately.

   Collections cannot contain directories names with spaces.  Please
either rename directories to use `_' instead of spaces, or move files
to another directory such as `/tmp/'.


File: marsyas.info,  Node: mkcollection,  Prev: Creating collections manually,  Up: Collections and input files

3.1.2 `mkcollection'
--------------------

`mkcollection' is a simple utility for creating collection files. To
create a collection of all the audio files residing in a directory the
following command can be used:

     mkcollection reggae.mf /home/gtzan/data/sound/

   All the soundfiles residing in that directory or any subdirectories
will be added to the collection.  `mkcollection' only will add files
with `.wav' and ` .au' extensions but does not check that they are
valid soundfiles.  In general collection files should contain
soundfiles with the same sampling rate as Marsyas does not perform
automatic sampling conversion. The exception to this rule is collection
that mix files at 22050Hz and 44100Hz sampling rates, in which case the
44100Hz files are downsampled to 22050Hz. No implicit downsampling is
performed to collections that contain only 44100Hz files.


File: marsyas.info,  Node: Simple Soundfile Interaction,  Next: Feature Extraction,  Prev: Collections and input files,  Up: Tools

3.2 Simple Soundfile Interaction
================================

* Menu:

* sfinfo::
* sfplay::


File: marsyas.info,  Node: sfinfo,  Next: sfplay,  Up: Simple Soundfile Interaction

3.2.1 `sfinfo'
--------------

sfinfo is a simple command-line utility for displaying information
about a soundfile. It is also a simple example of how printing out the
controls can show information like channels, sampling rate etc.

     sfinfo foo.wav


File: marsyas.info,  Node: sfplay,  Prev: sfinfo,  Up: Simple Soundfile Interaction

3.2.2 `sfplay'
--------------

sfplay is a flexible command-line soundfile player that allows playback
of multiple soundfiles in various formats with either real-time audio
output or soundfile output. The following two example show two extremes
of using of sfplay: simple playback of foo.wav and playing 3.2 seconds
(-l) clips starting at 10.0 seconds (-s) into the file and repeating
the clips for 2.5 times (-r) writing the output to output.wav (-f) at
half volume (-g) playing each file in the collection reggae.mf. The
last command stores the MarSystem dataflow network used in sfplay as a
plugin in playback.mpl. The plugin is essentially a textual description
of the created network.  Because MarSystems can be created at run-time
the network can be loaded in a sfplugin which is a generic executable
that flows audio data through any particular network.  Running sfplugin
-p playback.mpl bar.wav will play using the created plugin the file
bar.wav. It is important to note that although both sfplay and sfplugin
have the same behavior in this case they achieve it very different.
The main difference is that in sfplay the network is created at compile
time wheras in sfplugin the network is created at run time.

     sfplay foo.wav
     sfplay -s 10.0 -l 3.2 -r 2.5 -g 0.5 foo.wav bar.au -f output.wav
     sfplay -l 3.0 reggae.mf
     sfplay foo.wav -p playback.mpl


File: marsyas.info,  Node: Feature Extraction,  Next: Synthesis,  Prev: Simple Soundfile Interaction,  Up: Tools

3.3 Feature Extraction
======================

* Menu:

* pitchextract::
* extract::
* bextract::


File: marsyas.info,  Node: pitchextract,  Next: extract,  Up: Feature Extraction

3.3.1 `pitchextract'
--------------------

pitchextract is used to extract the fundamental frequency contour from
monophonic audio signals. A simple sinusoidal playback is provided for
playback of the resulting contour.


File: marsyas.info,  Node: extract,  Next: bextract,  Prev: pitchextract,  Up: Feature Extraction

3.3.2 `extract'
---------------

extract is a single-file executable for feature extraction.  It can be
used as part of external systems for feature extraction therefore it
outputs the results in a simple tab-separated text file. For more
serious feature extraction over multiple files check bextract which is
what I use most of the time. It also serves as an example of a network
of MarSystems with relatively complicated structure.  The following
commands extract a single vector of features based on the first 30
seconds of the provided soundfile. By default the feature extractor is
based on extracting features based on the magnitude of the Short Time
Fourier Transform (STFT) (i.e means and variances of Spectral Centroid,
Rolloff, Flux). The second command extracts the means and variances of
Mel-Frequency Cepstral Coefficients.

     extract foo.wav
     extract -e SVMFCC foo.wav


File: marsyas.info,  Node: bextract,  Prev: extract,  Up: Feature Extraction

3.3.3 `bextract'
----------------

bextract is one of the most powerful executables provided by Marsyas.
It can be used for complete feature extraction and classification
experiments with multiple files. It serves as a canonical example of
how audio analysis algorithms can be expressed in the framework.

   Suppose that you want to build a real-time music/speech descriminator
based on a collection of music files named music.mf and a collection of
speech files named speech.mf.  These collections can either be created
manually or using the mkcollection utility. The following commandline
will extract means and variances of Mel-Frequency cepstral coefficients
(MFCC) over a texture window of 1 sec.  The results are stored in a
wekaOut.arff which is a text file storing the feature values that can
be used in the Weka machine learning environment for experimentation
with different classifiers. At the same time that the features are
extracted, a simple Gaussian classifier is trained and when feature
extraction is completed the whole network of feature extraction and
classification is stored and can be used for real-time audio
classification directly as a Marsyas plugin.  The plugin makes a
classification decision every 20ms but aggregates the results by
majority voting to display output approximately every 1 second. The
whole network is stored in musp_classify.mpl which is loaded into
sfplugin and a new file named new.wav is passed through. The screen
output shows the classification results and confidence.

   Users familiar with marsyas 0.1 will notice that currently the
machine learning part of marsyas 0.2 is not as sophisticated as the one
of 0.1. For example there is no evaluate executable for performing
cross-validation experiments and the only classifier currently
implemented is a simple multidimensional Gaussian classifiar. For my
own research I have been increasingly using Weka for all the machine
learning experiments so porting this functionality to the new version
is not a high priority. On the other hand I have a clear notion of how
they can be integrated and most of the necessary components and APIs
are already in place. Eventually I would like to port most of Weka into
Marsyas but it will be some time until that happens.

     bextract -e STFT music.mf speech.mf -w wekaOut.arff -p musp_classify.mpl
     sfplugin -p musp_classify.mpl new.wav

   Feature extractors that start with SV produce one value for each
value and can be used for non-realtime classification such as genre
classification. The following command can be used to generate a weka
file for genre classification.

     bextract -e SVSTFT classical.mf jazz.mf rock.mf -w genre.arff

   Currently no classifier is generated for the SV feature extractors
but it's only a matter of time before this feature is added.  The
generated file genre.arff can the be loaded into Weka where
classification experiments can be conducted.


File: marsyas.info,  Node: Synthesis,  Next: Marsystem Interaction,  Prev: Feature Extraction,  Up: Tools

3.4 Synthesis
=============

* Menu:

* phasevocoder::
* sftransform::


File: marsyas.info,  Node: phasevocoder,  Next: sftransform,  Up: Synthesis

3.4.1 `phasevocoder'
--------------------

phasevocoder is probably the most powerful and canonical example of
sound synthesis provided currently by Marsyas. It is based on the
phasevocoder implementation described by F.R.Moore in his book
"Elements of Computer Music" . It is broken into individual MarSystems
in a modular way and can be used for real-time pitch-shifting and
time-scaling.

     phasevocoder -p 1.4 -s 100


File: marsyas.info,  Node: sftransform,  Prev: phasevocoder,  Up: Synthesis

3.4.2 `sftransform'
-------------------

sftransform is an example of having a doubly nested network with two
FFT/inverse FFT identity transformations.  It's not particularly useful
but show how to nested networks can be created.


File: marsyas.info,  Node: Marsystem Interaction,  Prev: Synthesis,  Up: Tools

3.5 Marsystem Interaction
=========================

* Menu:

* sfplugin::
* msl::


File: marsyas.info,  Node: sfplugin,  Next: msl,  Up: Marsystem Interaction

3.5.1 `sfplugin'
----------------

sfplugin is the universal executable. Any network of Marsystems stored
as a plugin can be loaded at run-time and sound can flow through the
network. The following example with appropriate plugins will peform
playback of foo.wav and playback with real time music speech
classification of foo.wav.

     sfplugin -p plugins/playback.mpl foo.wav
     sfplugin -p musp_classify.mpl foo.wav


File: marsyas.info,  Node: msl,  Prev: sfplugin,  Up: Marsystem Interaction

3.5.2 `msl'
-----------

One of the most useful and powerful characteristics of Marsyas is the
ability to create and combine MarSystems at run time.  msl (marsyas
scripting language) is a simple interpreter that can be used to create
dataflow networks, adjust controls, and run sound through the network.
It's used as a backend for user interfaces therefore it has limited (or
more accurately non-existent) editing functionality. The current syntax
is being revised so currently it's more a proof-of-concept.  Here is an
example of creating a simple network in msl and playing a sound file:

     msl
     [ msl ] create Series playbacknet
     [ msl ] create SoundFileSource src
     [ msl ] create Gain g
     [ msl ] create AudioSink dest
     [ msl ] add src  > playbacknet
     [ msl ] add g    > playbacknet
     [ msl ] add dest > playbacknet
     [ msl ] updctrl playbacknet SoundFileSource/src/string/filename technomusic.au
     [ msl ] run playbacknet

   The important thing to notice is that both the creation of MarSystems
and their assembly into networks can be done at run-time without having
to recompile any code. If anyone would like to pick a project to do for
Marsyas it would be to use the GNU readline utility for it's
commandline editing capabilities and try to come up with some
alternative syntax (I have some ideas in that direction).


File: marsyas.info,  Node: Architecture,  Next: Programming,  Prev: Tools,  Up: Top

4 Architecture
**************

In order to fully take advantage of the capabilities of Marsyas it is
important to understand how it works internally. The architecture of
Marsyas reflects an underlying dataflow model that we have found useful
in implementing real and non-real time audio analysis and synthesis
systems. In marsyas 0.2 a lot of things can be accomplished by
assembling complex networks of basic building blocks called MarSystems
that process data. This is the so called "Black-Box"

   functionality of the framework. In addition the programmer can also
write directly her/his own building blocks directly in C++ following a
certain API and coding conventions offering the so called "White-Box"
functionality. The next two sections describe building networks and
writing new MarSystems respectively.

* Menu:

* Architecture overview::
* Implicit patching::
* MarSystem Composites::


File: marsyas.info,  Node: Architecture overview,  Next: Implicit patching,  Up: Architecture

4.1 Architecture overview
=========================

* Menu:

* Building MarSystems::
* Dataflow model::


File: marsyas.info,  Node: Building MarSystems,  Next: Dataflow model,  Up: Architecture overview

4.1.1 Building MarSystems
-------------------------

The basic idea behind the design of Marsyas is that any audio
analysis/synthesis computation can be expressed as some type of
processing object, which we call MarSystem, that reads data from an
input slice of floating point numbers, performs some
computation/transformation based on data, and writes the results to
another slice of floating point numbers.  Networks of MarSystems can be
combined and encapsulated as one MarSystem.

   For example consider an audio processing series of computations
consisting of reading samples from a soundfile, performing an
short-time fourier transform (STFT) to calculate the complex spectrum,
performing an inverse STFT to convert back from the frequency domain to
time domain, then applying a gain to the amplitude of the samples and
writing the result to a soundfile.

   As is very frequently the case with audio processing networks objects
the input of each stage is the output of the previous stage.  This way
of assembling MarSystems is called a Series composite.  Once a Series
Composite is formed it can basically be used as one MarSystem that does
the whole thing. A figure showing a block diagram-like presentation of
this network is shown in the figure bellow.

   The main method that each MarSystem must support is process which
takes two arguments both arrays of floating point numbers used to
represent slices (matrices where one dimension is samples in time and
the other is observations which are interpreted as happening at the
same time). When the process method is called it reads data from the
input slice, performs some computation/transformation and writes the
results to the output slice. Both slices have to be preallocated when
process is called.  One of the main advantages of Marsyas is that a lot
of the necessary buffer allocation/reallocation and memory management
happens behind the scene without the programmer having to do anything
explicitly.


File: marsyas.info,  Node: Dataflow model,  Prev: Building MarSystems,  Up: Architecture overview

4.1.2 Dataflow model
--------------------

Marsyas follows a dataflow model of audio computation.

 [image src="images/dataflow.png" text="" ]

   Marsyas uses general matrices instead of 1-D arrays.  This allows
slices to be semantically correct.

 [image src="images/slices.png" text="" ]


File: marsyas.info,  Node: Implicit patching,  Next: MarSystem Composites,  Prev: Architecture overview,  Up: Architecture

4.2 Implicit patching
=====================

* Menu:

* Implicit patching vs. explicit patching::
* Implicit patching advantages::
* Patching example of Feature extraction::


File: marsyas.info,  Node: Implicit patching vs. explicit patching,  Next: Implicit patching advantages,  Up: Implicit patching

4.2.1 Implicit patching vs. explicit patching
---------------------------------------------

Many audio analysis programs require the user to explicitly (manually)
connect every processing block,

     # EXPLICIT PATCHING: block definitions
     source, F1, F2, F3, destination;
     # connect the in/out ports of the blocks
     connect(source, F1);
     connect(source, F2);
     connect(source, F3);
     connect(F1, destination);
     connect(F2, destination);
     connect(F3, destination);

 [image src="images/explicit-patching.png" text="" ]

   Marsyas uses _implicit patching_: connections are made automagically
when blocks are created,

     # IMPLICIT PATCHING
     source, F1, F2, F3, destination;
     Fanout(F1, F2, F3);
     Series(source, Fanout, destination);

 [image src="images/implicit-patching.png" text="" ]


File: marsyas.info,  Node: Implicit patching advantages,  Next: Patching example of Feature extraction,  Prev: Implicit patching vs. explicit patching,  Up: Implicit patching

4.2.2 Implicit patching advantages
----------------------------------

Creating a neural network with explicit patching soon becomes a mess,

 [image src="images/neural-explicit.png" text="" ]

   With implicit patching, this is much more manageable.

     # IMPLICIT PATCHING
     fanoutLayer1(ANN_Node11, ..., ANN_Node1N);
     ...
     fanoutLayerM(ANN_NodeM1, ..., ANN_NodeMN);
     ANN_Series(fanoutLayer1, ..., fanoutLayerM);

 [image src="images/neural-implicit.png" text="" ]

   Implicit patching can automagically adjust the connections without
requiring any code recompiliation.  For example, we can change the
number of bands in a filter bank without changing any code.

 [image src="images/implicit-filter-bank.png" text="" ]


File: marsyas.info,  Node: Patching example of Feature extraction,  Prev: Implicit patching advantages,  Up: Implicit patching

4.2.3 Patching example of Feature extraction
--------------------------------------------

Suppose we wish to create a typical feature extraction program:

 [image src="images/feature-extraction.png" text="" ]

     MarSystemManager mng;
     MarSystem* Series1 = mng.create("Series", "Series1");
     MarSystem* Fanout1 = mng.create("Fanout", "Fanout1");
     MarSystem* Series2 = mng.create("Series", "Series2");
     MarSystem* Fanout2 = mng.create("Fanout", "Fanout2");
     MarSystem* Fanout3 = mng.create("Fanout", "Fanout3");
     Fanout3->addMarSystem(mng.create("Mean", "Mean"));
     Fanout3->addMarSystem(mng.create("Variance", "Variance"));
     Fanout2->addMarSystem(mng.create("Centroid", "Centroid"));
     Fanout2->addMarSystem(mng.create("RollOff", "Rolloff"));
     Fanout2->addMarSystem(mng.create("Flux", "Flux");
     Series2->addMarSystem(mng.create("Spectrum, "Spectrum");
     Series2->addMarSystem(Fanout2);
     Fanout1->addMarSystem(mng.create("ZeroCrossings", "ZeroCrossings");
     Fanout1->addMarSystem(Series2);
     Series1->addMarSystem(mng.create("SoundFileSource", "Source"));
     Series1->addMarSystem(Fanout1);
     Series1->addMarSystem(mng.create("Memory", "TextureMemory"));
     Series1->addMarSystem(Fanout3);
     Series1->addMarSystem(mng.create("classifier", "Classifier"));


File: marsyas.info,  Node: MarSystem Composites,  Prev: Implicit patching,  Up: Architecture

4.3 MarSystem Composites
========================

* Menu:

* Series::
* Parallel::
* Fanout::
* Accumulator::


File: marsyas.info,  Node: Series,  Next: Parallel,  Up: MarSystem Composites

4.3.1 Series
------------

 [image src="images/composite-series.png" text="" ]


File: marsyas.info,  Node: Parallel,  Next: Fanout,  Prev: Series,  Up: MarSystem Composites

4.3.2 Parallel
--------------

 [image src="images/composite-parallel.png" text="" ]


File: marsyas.info,  Node: Fanout,  Next: Accumulator,  Prev: Parallel,  Up: MarSystem Composites

4.3.3 Fanout
------------

 [image src="images/composite-fanout.png" text="" ]


File: marsyas.info,  Node: Accumulator,  Prev: Fanout,  Up: MarSystem Composites

4.3.4 Accumulator
-----------------

 [image src="images/composite-accumulator.png" text="" ]


File: marsyas.info,  Node: Programming,  Next: Interoperability,  Prev: Architecture,  Up: Top

5 Programming
*************

* Menu:

* Assembling a network::
* Writing your own MarSystems::


File: marsyas.info,  Node: Assembling a network,  Next: Writing your own MarSystems,  Up: Programming

5.1 Assembling a network
========================

* Menu:

* Including libraries and linking::
* Hello World (playing an audio file)::
* Reading and altering controls::
* Writing data to text files::
* Getting data from the network::
* Scheduler::


File: marsyas.info,  Node: Including libraries and linking,  Next: Hello World (playing an audio file),  Up: Assembling a network

5.1.1 Including libraries and linking
-------------------------------------

Unless you write your program inside the `marsyas/src' directory, you
need to include the Marsyas libraries in your project.

Linux and other *nixes
......................

The easiest way to compile Marsyas projects is to use a makefile.  In
your working directory, create a file called `Makefile' which contains

     all:
     	rm -f *.o
     	g++ -Wall -O2 -I./ -I/usr/local/include/marsyas -c -o myfile.o myfile.cpp
     	g++ -Lusr/local/lib -o myfile myfile.o -lmarsyas -lasound

(place a tab in front of the three lower lines instead of spaces)

   If you installed marsyas in a location other than `/usr/local/', then
change the `-I' and `-L' directories accordingly.  For example, if you
installed marsyas in `${HOME}/usr/', then you would use
`-I${HOME}/usr/include/marsyas' and `-L${HOME}/usr/lib'.  Once the
`Makefile' is written, simply type `make' to compile your file.

OSX
...

To compile Marsyas projects in OSX, use the same `Makefile' as is used
in other *nixes, but replace the final line with

     	g++ -Lusr/local/lib -o myfile myfile.o -lmarsyas -framework CoreAudio \
     		-framework CoreMidi -framework CoreFoundation

Windows Visual Studio
.....................

Please see the documentation for your compiler / development
environment.


File: marsyas.info,  Node: Hello World (playing an audio file),  Next: Reading and altering controls,  Prev: Including libraries and linking,  Up: Assembling a network

5.1.2 Hello World (playing an audio file)
-----------------------------------------

Instead of printing "Hello World!"  , we shall play a sound file.  This
is relatively straightforward: we create a `MarSystem' which is a
series of `SoundFileSource', `Gain', and `AudioSink'.  Once the network
is created and the controls are given, we call `tick()' to make time
pass until we have finished playing the file.

helloworld.cpp
..............

     #include "MarSystemManager.h"
     using namespace std;
     using namespace Marsyas;

     void sfplay(string sfName, float gain) {
            MarSystemManager mng;

            MarSystem* playbacknet = mng.create("Series", "playbacknet");

            playbacknet->addMarSystem(mng.create("SoundFileSource", "src"));
            playbacknet->addMarSystem(mng.create("Gain", "gt"));
            playbacknet->addMarSystem(mng.create("AudioSink", "dest"));

            playbacknet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
            playbacknet->updctrl("Gain/gt/mrs_real/gain", gain);
            playbacknet->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

            while ( playbacknet->getctrl("SoundFileSource/src/mrs_bool/notEmpty")->toBool() ) {
                   playbacknet->tick();
            }
            delete playbacknet;
     }

     int main(int argc, const char **argv) {
            string fileName;
            float gain;
            if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else
                   { fileName = argv[1]; }
            if (argc<3) { gain = 1; } else
                   { gain = atof(argv[2]); }
            cout << "Playing file " << fileName << " at volume " <<
                   gain << endl;

            sfplay(fileName,gain);
            exit(0);
     }


File: marsyas.info,  Node: Reading and altering controls,  Next: Writing data to text files,  Prev: Hello World (playing an audio file),  Up: Assembling a network

5.1.3 Reading and altering controls
-----------------------------------

Here we have modified the example from the previous section: we have
added the ability to start at an arbitrary position (time) inside the
audio file.  To calculate the starting position in the file, we must
know the sample rate and number of channels.  We get this information
from the `SoundFileSource' with `getctrl'.

controls.cpp
............

     #include "MarSystemManager.h"
     using namespace std;
     using namespace Marsyas;

     void sfplay(string sfName, float gain, float start) {
            MarSystemManager mng;

            MarSystem* playbacknet = mng.create("Series", "playbacknet");

            playbacknet->addMarSystem(mng.create("SoundFileSource", "src"));
            playbacknet->addMarSystem(mng.create("Gain", "gt"));
            playbacknet->addMarSystem(mng.create("AudioSink", "dest"));

     // calculate the starting position.
            mrs_natural nChannels = playbacknet->getctrl("SoundFileSource/src/mrs_natural/nChannels")->toNatural();
            mrs_real srate = playbacknet->getctrl("SoundFileSource/src/mrs_real/israte")->toReal();
            mrs_natural startPosition = (mrs_natural) (start * srate * nChannels);

            playbacknet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
            playbacknet->updctrl("Gain/gt/mrs_real/gain", gain);
            playbacknet->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

     // set the starting position of the source
            playbacknet->updctrl("SoundFileSource/src/mrs_natural/pos", startPosition);

            while ( playbacknet->getctrl("SoundFileSource/src/mrs_bool/notEmpty")->toBool() ) {
                   playbacknet->tick();
            }
            delete playbacknet;
     }

     int main(int argc, const char **argv) {
            string fileName;
            float gain, start;
            if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else
                   { fileName = argv[1]; }
            if (argc<3) { gain = 1; } else
                   { gain = atof(argv[2]); }
            if (argc<4) { start = 0; } else
                   { start = atof(argv[3]); }
            cout << "Playing file " << fileName << " at volume " <<
                   gain << " starting at " << start << " seconds" << endl;

            sfplay(fileName,gain,start);
            exit(0);
     }


File: marsyas.info,  Node: Writing data to text files,  Next: Getting data from the network,  Prev: Reading and altering controls,  Up: Assembling a network

5.1.4 Writing data to text files
--------------------------------

Extract data from a network for further analysis (plotting, other
programs, etc) is fairly easy to do with `PlotSink'.

writefile.cpp
.............

     #include "MarSystemManager.h"
     using namespace std;
     using namespace Marsyas;

     void recognize(string sfName) {
            MarSystemManager mng;
            MarSystem* pnet = mng.create("Series", "pnet");
     // standard network
            pnet->addMarSystem(mng.create("SoundFileSource", "src"));
            pnet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
            pnet->addMarSystem(mng.create("Spectrum","spk"));

     // add a PlotSink wherever we want to get data from
            pnet->addMarSystem(mng.create("PlotSink","plot"));
            pnet->updctrl("PlotSink/plot/mrs_string/outputFilename", "out");

            while ( pnet->getctrl("SoundFileSource/src/mrs_bool/notEmpty")->toBool() ) {
                   pnet->tick();
            }
            delete pnet;
     }

     int main(int argc, const char **argv) {
            string fileName;
            if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else
                   { fileName = argv[1]; }
            cout << "Processing file " << fileName << endl;

            recognize(fileName);
            exit(0);
     }


File: marsyas.info,  Node: Getting data from the network,  Next: Scheduler,  Prev: Writing data to text files,  Up: Assembling a network

5.1.5 Getting data from the network
-----------------------------------

Putting together a network of MarSystems is all well and good, but you
probably want to do something with that data.  In this example we
simply print it to the screen, but the important thing to note is that
we have the data at the level of C programming.

gettingdata.cpp
...............

     #include "MarSystemManager.h"
     using namespace std;
     using namespace Marsyas;

     void recognize(string sfName) {
            MarSystemManager mng;
            MarSystem* pnet = mng.create("Series", "pnet");
     // standard network
            pnet->addMarSystem(mng.create("SoundFileSource", "src"));
            pnet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
            pnet->addMarSystem(mng.create("Spectrum","spk"));

     // variables to get data from network
            realvec in(pnet->getctrl("mrs_natural/inObservations")->toNatural(), pnet->getctrl("mrs_natural/inSamples")->toNatural());
            realvec out(pnet->getctrl("mrs_natural/onObservations")->toNatural(), pnet->getctrl("mrs_natural/onSamples")->toNatural());

     // counter variables
            int i,j;
            mrs_natural numberObservations = pnet->getctrl("mrs_natural/onObservations")->toNatural();
            mrs_natural numberSamples = pnet->getctrl("mrs_natural/onSamples")->toNatural();

            while ( pnet->getctrl("SoundFileSource/src/mrs_bool/notEmpty")->toBool() ) {
                   pnet->tick();
     // get data from network
                   pnet->process(in,out);

     // display data
                   for (i=0; i<numberObservations; i++) {
                          for (j=0; j<numberSamples; j++) {
                                 cout<<out(i,j)<<" ";
                          }
                   }
                   cout<<endl;
            }
            delete pnet;
     }

     int main(int argc, const char **argv) {
            string fileName;
            if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else
                   { fileName = argv[1]; }
            cout << "Processing file " << fileName << endl;

            recognize(fileName);
            exit(0);
     }


File: marsyas.info,  Node: Scheduler,  Prev: Getting data from the network,  Up: Assembling a network

5.1.6 Scheduler
---------------

To schedule events using the new scheduler code, see the Marsyas
Expression Syntax documentation at
`http://www.cs.uvic.ca/~inb/work/expr.html'


File: marsyas.info,  Node: Writing your own MarSystems,  Prev: Assembling a network,  Up: Programming

5.2 Writing your own MarSystems
===============================

It's relatively straightforward to extend Marsyas by writing your own
Marsystems. As mentioned before each MarSystems must basically support
the process method that handles the dataflow and the update method that
handles the control messages.  There are certain conventions that need
to be followed so typically it is a better idea to copy and modify an
existing Marsystem rather than writing one from scratch. The simple
canonical example of a MarSystem that is what I use as a template when
I write a new Marsystem is Gain.h and Gain.cpp


File: marsyas.info,  Node: Interoperability,  Next: Future Work,  Prev: Programming,  Up: Top

6 Interoperability
******************

Intro text

* Menu:

* Audio and MIDI::
* Open Sound Control (OSC)::
* WEKA::
* MATLAB::
* Python::
* Trolltech Qt4::
* OCaml::


File: marsyas.info,  Node: Audio and MIDI,  Next: Open Sound Control (OSC),  Up: Interoperability

6.1 Audio and MIDI
==================

   * *RtAudio*: Multiplatform C++ API for realtime audio input/output

        - Linux (native ALSA, JACK, and OSS)

        - MacOSX(C)

        - Windows(C) (DirectSound(C) and ASIO(C))

        - SGI(C)

   * *RtMIDI*: Multiplatform C++ API for realtime MIDI input/output

        - Linux (ALSA)

        - MacOSX(C)

        - Windows(C)

        - SGI(C)


   `http://www.music.mcgill.ca/~gary/rtaudio/'

   `http://www.music.mcgill.ca/~gary/rtmidi/'


File: marsyas.info,  Node: Open Sound Control (OSC),  Next: WEKA,  Prev: Audio and MIDI,  Up: Interoperability

6.2 Open Sound Control (OSC)
============================

This is coming soon, right George?  It had better be soon...


File: marsyas.info,  Node: WEKA,  Next: MATLAB,  Prev: Open Sound Control (OSC),  Up: Interoperability

6.3 WEKA
========


File: marsyas.info,  Node: MATLAB,  Next: Python,  Prev: WEKA,  Up: Interoperability

6.4 MATLAB
==========


File: marsyas.info,  Node: Python,  Next: Trolltech Qt4,  Prev: MATLAB,  Up: Interoperability

6.5 Python
==========


File: marsyas.info,  Node: Trolltech Qt4,  Next: OCaml,  Prev: Python,  Up: Interoperability

6.6 Trolltech Qt4
=================

To get started, look at the tutorial files:

tutorial.pro
............

     #  your files
     SOURCES = main.cpp
     HEADERS = mainwindow.h
     SOURCES += mainwindow.cpp
     HEADERS += backend.h
     SOURCES += backend.cpp

     #  these files are common to every Marsyas/QT app
     HEADERS += ../MarSystemQtWrapper.h
     SOURCES += ../MarSystemQtWrapper.cpp

     #  basic system variables
     TARGET = runme
     INCLUDEPATH += ${HOME}/usr/include/marsyas
     unix:LIBS += -lmarsyas -L/usr/local/lib # -lmad -lvorbis -lvorbisfile
     !macx:LIBS += -lasound
     macx:LIBS += -framework CoreAudio -framework CoreMidi -framework CoreFoundation

main.cpp
........

     /*
     ** Copyright (C) 2007 Graham Percival <gperciva@uvic.ca>
     **
     ** This program is free software; you can redistribute it and/or modify
     ** it under the terms of the GNU General Public License as published by
     ** the Free Software Foundation; either version 2 of the License, or
     ** (at your option) any later version.
     **
     ** This program is distributed in the hope that it will be useful,
     ** but WITHOUT ANY WARRANTY; without even the implied warranty of
     ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ** GNU General Public License for more details.
     **
     ** You should have received a copy of the GNU General Public License
     ** along with this program; if not, write to the Free Software
     ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
     */

     #include "mainwindow.h"
     int main(int argc, char *argv[]) {
     // to keep this example as simple as possible, we only take the
     // filename from the command-line.
            string fileName;
            if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else
                   { fileName = argv[1]; }

            QApplication app(argc, argv);
            MarQTwindow marqt(fileName);
            marqt.show();
            return app.exec();
     }

mainwindow.h
............

     /*
     ** Copyright (C) 2007 Graham Percival <gperciva@uvic.ca>
     **
     ** This program is free software; you can redistribute it and/or modify
     ** it under the terms of the GNU General Public License as published by
     ** the Free Software Foundation; either version 2 of the License, or
     ** (at your option) any later version.
     **
     ** This program is distributed in the hope that it will be useful,
     ** but WITHOUT ANY WARRANTY; without even the implied warranty of
     ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ** GNU General Public License for more details.
     **
     ** You should have received a copy of the GNU General Public License
     ** along with this program; if not, write to the Free Software
     ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
     */

     #include <QApplication>
     #include <QPushButton>
     #include <QSlider>
     #include <QVBoxLayout>
     #include <QLCDNumber>

     #include <iostream>
     using namespace std;

     #include "backend.h"

     class MarQTwindow : public QWidget {
            Q_OBJECT
     public:
            MarQTwindow(string fileName);
            ~MarQTwindow();

     public slots:
            void setMainPosition(int newPos);

     private:
            MarBackend *marBackend;
            QLCDNumber *lcd;
     };

mainwindow.cpp
..............

     /*
     ** Copyright (C) 2007 Graham Percival <gperciva@uvic.ca>
     **
     ** This program is free software; you can redistribute it and/or modify
     ** it under the terms of the GNU General Public License as published by
     ** the Free Software Foundation; either version 2 of the License, or
     ** (at your option) any later version.
     **
     ** This program is distributed in the hope that it will be useful,
     ** but WITHOUT ANY WARRANTY; without even the implied warranty of
     ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ** GNU General Public License for more details.
     **
     ** You should have received a copy of the GNU General Public License
     ** along with this program; if not, write to the Free Software
     ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
     */

     #include "mainwindow.h"

     MarQTwindow::MarQTwindow(string fileName) {
     // typical Qt front-end
            QPushButton *quit = new QPushButton(tr("Quit"));
            connect(quit, SIGNAL(clicked()), qApp, SLOT(quit()));

            QPushButton *updatePos = new QPushButton(tr("Update position"));

            QSlider *volume = new QSlider (Qt::Horizontal);
            volume->setRange(0,100);
            volume->setValue(50);

            lcd = new QLCDNumber();
            lcd->setNumDigits(10);

            QVBoxLayout *layout = new QVBoxLayout;
            layout->addWidget(volume);
            layout->addWidget(updatePos);
            layout->addWidget(lcd);
            layout->addWidget(quit);
            setLayout(layout);

     // make the Marsyas backend
            marBackend = new MarBackend();
            marBackend->openBackendSoundfile(fileName);

     // make connections between the Qt front-end and the Marsyas backend:

     //              Qt -> Marsyas
            connect(volume, SIGNAL(valueChanged(int)),
                          marBackend, SLOT(setBackendVolume(int)));

     //              Marsyas -> Qt
            connect(marBackend, SIGNAL(changedBackendPosition(int)),
                          this, SLOT(setMainPosition(int)));

     //              Qt -> Marsyas (getBackendPosition) -> Qt (changedBackendPosition)
            connect(updatePos, SIGNAL(clicked()),
                          marBackend, SLOT(getBackendPosition()));
     }

     MarQTwindow::~MarQTwindow() {
            delete marBackend;
     }

     void MarQTwindow::setMainPosition(int newPos) {
            lcd->display(newPos);
     }

backend.h
.........

     /*
     ** Copyright (C) 2007 Graham Percival <gperciva@uvic.ca>
     **
     ** This program is free software; you can redistribute it and/or modify
     ** it under the terms of the GNU General Public License as published by
     ** the Free Software Foundation; either version 2 of the License, or
     ** (at your option) any later version.
     **
     ** This program is distributed in the hope that it will be useful,
     ** but WITHOUT ANY WARRANTY; without even the implied warranty of
     ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ** GNU General Public License for more details.
     **
     ** You should have received a copy of the GNU General Public License
     ** along with this program; if not, write to the Free Software
     ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
     */

     #include <QObject>
     #include <QTimer>
     #include "MarSystemManager.h"
     #include "../MarSystemQtWrapper.h"

     #include <iostream>
     using namespace std;
     using namespace Marsyas;

     class MarBackend: public QObject {
            Q_OBJECT

     public:
            MarBackend();
            ~MarBackend();
            void openBackendSoundfile(string fileName);

     public slots:
            void setBackendVolume(int value);
            void getBackendPosition();

     signals:
            void changedBackendPosition(int value);

     private:
     // in order to make the MarSystem act like a Qt object,
     // we use this wrapper:
            MarSystemQtWrapper *mrsWrapper;
     // ... and these pointers:
            MarControlPtr filenamePtr;
            MarControlPtr gainPtr;
            MarControlPtr positionPtr;

     // typical Marsyas network:
            MarSystem *playbacknet;
     };

backend.cpp
...........

     /*
     ** Copyright (C) 2007 Graham Percival <gperciva@uvic.ca>
     **
     ** This program is free software; you can redistribute it and/or modify
     ** it under the terms of the GNU General Public License as published by
     ** the Free Software Foundation; either version 2 of the License, or
     ** (at your option) any later version.
     **
     ** This program is distributed in the hope that it will be useful,
     ** but WITHOUT ANY WARRANTY; without even the implied warranty of
     ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ** GNU General Public License for more details.
     **
     ** You should have received a copy of the GNU General Public License
     ** along with this program; if not, write to the Free Software
     ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
     */

     #include "backend.h"
     using namespace Marsyas;

     MarBackend::MarBackend() {
     // make a typical Marsyas network:
            MarSystemManager mng;
            playbacknet = mng.create("Series", "playbacknet");
            playbacknet->addMarSystem(mng.create("SoundFileSource", "src"));
            playbacknet->addMarSystem(mng.create("Gain", "gain"));
            playbacknet->addMarSystem(mng.create("AudioSink", "dest"));
            playbacknet->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

     // wrap it up to make it pretend to be a Qt object:
            mrsWrapper = new MarSystemQtWrapper(playbacknet);
            mrsWrapper->start();

     // make these pointers so that we can interface with the network
     // in a thread-safe manner:
            filenamePtr = mrsWrapper->getctrl("SoundFileSource/src/mrs_string/filename");
            gainPtr = mrsWrapper->getctrl("Gain/gain/mrs_real/gain");
            positionPtr = mrsWrapper->getctrl("SoundFileSource/src/mrs_natural/pos");

     // demonstrates information flow:  Marsyas->Qt.
            QTimer *timer = new QTimer(this);
            connect(timer, SIGNAL(timeout()), this, SLOT(getBackendPosition()));
            timer->start(1000);
     }

     MarBackend::~MarBackend() {
            delete mrsWrapper;
            delete playbacknet;
     }

     void MarBackend::openBackendSoundfile(string fileName) {
            mrsWrapper->updctrl(filenamePtr,fileName);
     }

     void MarBackend::setBackendVolume(int vol) {
            float newGain = vol/100.0f;
            mrsWrapper->updctrl(gainPtr, newGain);
     }

     void MarBackend::getBackendPosition() {
            int newPos = (int) positionPtr->to<mrs_natural>();
            emit changedBackendPosition(newPos);
     }

   After examining that project, see `qtGUIs/MarPlayer/', followed by
the other examples in the `qtGUIs/' directory.


File: marsyas.info,  Node: OCaml,  Prev: Trolltech Qt4,  Up: Interoperability

6.7 OCaml
=========

To combine Marsyas and OCaml, see the MarsyasOCaml documentation at
`http://www.cs.uvic.ca/~inb/work/marsyasOCaml/'


File: marsyas.info,  Node: Future Work,  Next: Users and Projects,  Prev: Interoperability,  Up: Top

7 Future Work
*************

As is the case with most software projects, there is a lot of future
work that I would like to do and I welcome any assistance, feedback,
requests for features you might have. Most of my plans can be found in
the TODO file of the distribution. However it is not clearly written
and intended for my own personal use.

   Some of the more long-term and ambitious plans for the future will be
described in this section. If you would like to contribute some code to
the project and you don't know where to start this section might give
you some ideas.

   python bindings msl interpreter with vertical syntax msl interpreter
with chuck-like syntax SDIFF IO Open Sound Control (OSC)


File: marsyas.info,  Node: Users and Projects,  Next: The Index,  Prev: Future Work,  Up: Top

8 Users and Projects
********************

One of the greatest feelings a researcher/programmer can have is
learning about people around the world doing exciting things with
her/his software. There have been many amazing projects done with
Marsyas and I hope to include them all in this section.  If you are
working on Marsyas and your name is not here, I would love to learn
about your project and include it in this section. Also send me an
email if you are one of the people mentioned in this section and you
have some more information about how marsyas was used in your project.
I would also like to thank all of you who have found Marsyas useful and
helped me make it a better software framework.

   (NOTES TO MYSELF about what I should write)

   Mark Cardle Moodlogic AllMusic Inc. The Netherlands IslandGame Luis
Gustavo Martins Stephaan Lippens Tao Li Karin Koshina ??? (spelling)
Chris West  ??? (spelling) George Tourtellot Corrie Elder Kris West

   The subdirectory distributed contains sources and sinks that can be
used to transmit sound and in general marsyas data over the network
using TCP and UDP protocols. It enables cool thing like reading
soundfiles on one computer sending fft frames for analysis to multiple
computers and then assembling the results. The actual code has only be
tested under Linux and is under construction so you at your own risk or
even better fix the problems.


File: marsyas.info,  Node: The Index,  Prev: Users and Projects,  Up: Top

The Index
*********

 [index ]
* Menu:

* bextract:                              bextract.             (line  6)
* Compiling:                             Including libraries and linking.
                                                               (line  6)
* Cygwin:                                Windows (cygwin).     (line  6)
* extract:                               extract.              (line  6)
* Hello world:                           Hello World (playing an audio file).
                                                               (line  6)
* Linking:                               Including libraries and linking.
                                                               (line  6)
* Linux:                                 Linux Installation.   (line  6)
* Mac OSX:                               Mac OSX Installation. (line  6)
* mkcollection:                          mkcollection.         (line  6)
* msl:                                   msl.                  (line  6)
* Perry Cook:                            History.              (line  8)
* phasevocoder:                          phasevocoder.         (line  6)
* pitchextract:                          pitchextract.         (line  6)
* Playing an audio file:                 Hello World (playing an audio file).
                                                               (line  6)
* QT4:                                   Configure Options.    (line 38)
* sfinfo:                                sfinfo.               (line  6)
* sfplay:                                sfplay.               (line  6)
* sfplugin:                              sfplugin.             (line  6)
* sftransform:                           sftransform.          (line  6)
* Tzanetakis, George:                    Introduction.         (line  9)
* Windows:                               Windows (Visual Studio).
                                                               (line  6)



Tag Table:
Node: Top1065
Node: Introduction1810
Node: History4145
Node: Context and Related Work6122
Node: About the documentation11101
Node: Installation13532
Node: Download13823
Node: Linux Installation15069
Node: Mac OSX Installation15916
Node: Windows (cygwin)16763
Node: Windows (Visual Studio)17386
Node: Configure Options18102
Node: Structure of distribution20097
Node: Tools22660
Node: Collections and input files23368
Node: Creating collections manually23759
Node: mkcollection24709
Node: Simple Soundfile Interaction25701
Node: sfinfo25934
Node: sfplay26276
Node: Feature Extraction27739
Node: pitchextract27954
Node: extract28259
Node: bextract29251
Node: Synthesis32266
Node: phasevocoder32447
Node: sftransform32951
Node: Marsystem Interaction33261
Node: sfplugin33427
Node: msl33928
Node: Architecture35370
Node: Architecture overview36356
Node: Building MarSystems36559
Node: Dataflow model38631
Node: Implicit patching39028
Node: Implicit patching vs. explicit patching39329
Node: Implicit patching advantages40298
Node: Patching example of Feature extraction41222
Node: MarSystem Composites42676
Node: Series42884
Node: Parallel43047
Node: Fanout43231
Node: Accumulator43414
Node: Programming43595
Node: Assembling a network43789
Node: Including libraries and linking44144
Node: Hello World (playing an audio file)45621
Node: Reading and altering controls47590
Node: Writing data to text files50170
Node: Getting data from the network51692
Node: Scheduler54048
Node: Writing your own MarSystems54331
Node: Interoperability55042
Node: Audio and MIDI55307
Node: Open Sound Control (OSC)55904
Node: WEKA56139
Node: MATLAB56264
Node: Python56375
Node: Trolltech Qt456495
Node: OCaml67240
Node: Future Work67459
Node: Users and Projects68271
Node: The Index69776

End Tag Table
