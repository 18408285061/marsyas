@node Tools, Architecture, Installation, Top
@chapter Tools

The main goal of Marsyas is to provide an extensible framework that
can be used to quickly design and experiment with audio analysis and
synthesis applications. It is important to realize that Marsyas is a
framework for building applications rather than a set of
applications. The tools provided with the distribution, although
directly useful, are only representative examples of what can be
achieved using the provided components. They are also used as a
testbed to design/benchmark/experiment with the framework. Marsyas is
meant to be an extensible framework so making the effort of
understanding the code behind the executables is necessary for any
serious work. These tools also show the capabilities of the framework 
and also serve as pedagogical examples.


@menu
* Collections::                 
@end menu

@node Collections
@section Collections

Many of the Marsyas tools operate either on individual soundfiles or
collections which are simple text files that contain lists of 
soundfiles. 

A simple way to create a collection is the unix ls command. 
For example: 

@example
> ls /home/gtzan/data/sound/reggae/*.wav > reggae.mf
@end example

The collection will then look like as follows: 
@example
/home/gtzan/data/sound/reggae/foo.wav 
/home/gtzan/data/sound/reggae/bar.wav 
@end example

Any text editor or program that generates text can be used to create
collection files. The only constraint is that the name of the
collections file must have a .mf extension such as reggae.mf. Also any
line starting with the # character is ignored. For the Windows Visual
Studio version change the slash character separating directories
appropriately.


In addition, a simple commandline utility called mkcollection is
provided for easy creation of collections.  More information about
mkcollection is provided bellow.  Most executables operate on either
soundfiles or collections interchangeably.


The following executables are provided in marsyas: 

     
@enumerate

@item @emph{mkcollection}
@cindex mkcollection     
 
mkcollection is a simple utility for creating collection 
files. To create a collection of all the audio files residing 
in a directory the following command can be used: 

@example 
> mkcollection reggae.mf /home/gtzan/data/sound/ 
@end example

All the soundfiles residing in the directory provided by the second
argument will be added to the collection.  If there are subdirectories
mkcollection will recursively scan through. mkcollection only will add
files with .wav, .au extension but doesn't check that they are valid
soundfiles or that they are in one of the supported Marsyas
formats. mkcollection is not necessary for creating collections as
they can be created with any text editor or using ls. In general
collection files should contain soundfiles with the same sampling rate
as Marsyas doesn't perform automatic sampling conversion. The
exception to this rule is collection that mix files at 22050Hz and
44100Hz sampling rates in which case the 44100Hz files are downsampled
to 22050Hz. No implicit downsampling is performed to Collections that
contain only 44100Hz files.

@item @emph{sfplay}
@cindex sfplay 

sfplay is a flexible command-line soundfile player that allows
playback of multiple soundfiles in various formats with either
real-time audio output or soundfile output. The following two example
show two extremes of using of sfplay: simple playback of foo.wav and
playing 3.2 seconds (-l) clips starting at 10.0 seconds (-s) into the
file and repeating the clips for 2.5 times (-r) writing the output to
output.wav (-f) at half volume (-g) playing each file in the
collection reggae.mf. The last command stores the MarSystem dataflow
network used in sfplay as a plugin in playback.mpl. The plugin is
essentially a textual description of the created network.  Because
MarSystems can be created at run-time the network can be loaded in a
sfplugin which is a generic executable that flows audio data through
any particular network.  Running sfplugin -p playback.mpl bar.wav will
play using the created plugin the file bar.wav. It is important to
note that although both sfplay and sfplugin have the same behavior in
this case they achieve it very different.  The main difference is that
in sfplay the network is created at compile time wheras in sfplugin
the network is created at run time.


@example
> sfplay foo.wav 
> sfplay -s 10.0 -l 3.2 -r 2.5 -g 0.5 foo.wav bar.au -f output.wav
> sfplay -l 3.0 reggae.mf
> sfplay foo.wav -p playback.mpl 
@end example


@item @emph{sfplugin}
@cindex sfplugin

sfplugin is the universal executable. Any network of Marsystems 
stored as a plugin can be loaded at run-time and sound can flow 
through the network. The following example with appropriate plugins 
will peform playback of foo.wav and playback with real time music
speech classification of foo.wav. 

@example 
> sfplugin -p plugins/playback.mpl foo.wav
> sfplugin -p musp_classify.mpl foo.wav
@end example 


@item @emph{sfinfo}
@cindex sfinfo

sfinfo is a simple command-line utility for displaying 
information about a soundfile. It is also a simple 
example of how printing out the controls can show 
information like channels, sampling rate etc.  

@example 
> sfinfo foo.wav 
@end example 


@item @emph{extract}

extract is a single-file executable for feature extraction. 
It can be used as part of external systems for feature 
extraction therefore it outputs the results in a simple 
tab-separated text file. For more serious feature extraction 
over multiple files check bextract which is what I use most 
of the time. It also serves as an example of a network 
of MarSystems with relatively complicated structure.  
The following commands extract a single vector of features 
based on the first 30 seconds of the provided 
soundfile. By default the feature extractor is based on 
extracting features based on the magnitude of the Short Time 
Fourier Transform (STFT) (i.e means and variances of Spectral 
Centroid, Rolloff, Flux). The second command extracts 
the means and variances of Mel-Frequency Cepstral 
Coefficients. 

@example 
> extract foo.wav 
> extract -e SVMFCC foo.wav
@end example 



@item @emph{bextract}

bextract is one of the most powerful executables provided by
Marsyas. It can be used for complete feature extraction and
classification experiments with multiple files. It serves as a
canonical example of how audio analysis algorithms can be expressed in
the framework.

Suppose that you want to build a real-time music/speech descriminator
based on a collection of music files named music.mf and a collection
of speech files named speech.mf.  These collections can either be
created manually or using the mkcollection utility. The following
commandline will extract means and variances of Mel-Frequency cepstral
coefficients (MFCC) over a texture window of 1 sec.  The results are
stored in a wekaOut.arff which is a text file storing the feature
values that can be used in the Weka machine learning environment for
experimentation with different classifiers. At the same time that the
features are extracted, a simple Gaussian classifier is trained and
when feature extraction is completed the whole network of feature
extraction and classification is stored and can be used for real-time
audio classification directly as a Marsyas plugin.  The plugin makes a
classification decision every 20ms but aggregates the results by
majority voting to display output approximately every 1 second. The
whole network is stored in musp_classify.mpl which is loaded into
sfplugin and a new file named new.wav is passed through. The screen
output shows the classification results and confidence.

Users familiar with marsyas 0.1 will notice that currently the machine
learning part of marsyas 0.2 is not as sophisticated as the one of
0.1. For example there is no evaluate executable for performing
cross-validation experiments and the only classifier currently
implemented is a simple multidimensional Gaussian classifiar. For my
own research I have been increasingly using Weka for all the machine
learning experiments so porting this functionality to the new version
is not a high priority. On the other hand I have a clear notion of how
they can be integrated and most of the necessary components and APIs
are already in place. Eventually I would like to port most of Weka
into Marsyas but it will be some time until that happens.



@example 
> bextract -e STFT music.mf speech.mf -w wekaOut.arff -p musp_classify.mpl
> sfplugin -p musp_classify.mpl new.wav 
@end example

Feature extractors that start with SV produce one value 
for each value and can be used for non-realtime classification 
such as genre classification. The following command can 
be used to generate a weka file for genre classification. 

@example 
> bextract -e SVSTFT classical.mf jazz.mf rock.mf -w genre.arff
@end example 

Currently no classifier is generated for the SV feature extractors 
but it's only a matter of time before this feature is added. 
The generated file genre.arff can the be loaded into Weka 
where classification experiments can be conducted. 




@item @emph{phasevocoder}
phasevocoder is probably the most powerful and canonical example of
sound synthesis provided currently by Marsyas. It is based on the
phasevocoder implementation described by F.R.Moore in his book
``Elements of Computer Music''. It is broken into individual
MarSystems in a modular way and can be used for real-time
pitch-shifting and time-scaling.
 




@item @emph{sftransform}
sftransform is an example of having a doubly nested 
network with two FFT/inverse FFT identity transformations. 
It's not particularly useful but show how 
to nested networks can be created.


@item @emph{pitchextract}
pitchextract is used to extract the fundamental frequency 
contour from monophonic audio signals. A simple sinusoidal 
playback is provided for playback of the resulting contour. 


@item @emph{msl}

One of the most useful and powerful characteristics of Marsyas 
is the ability to create and combine MarSystems at run time. 
msl (marsyas scripting language) is a simple interpreter 
that can be used to create dataflow networks, adjust controls, 
and run sound through the network. It's used as a backend for 
user interfaces therefore it has limited (or more accurately
non-existent) editing functionality. The current syntax 
is being revised so currently it's more a proof-of-concept. 
Here is an example of creating a simple network in msl and 
playing a sound file: 

@example 
>msl 
[ msl ] create Series playbacknet
[ msl ] create SoundFileSource src
[ msl ] create Gain g
[ msl ] create AudioSink dest
[ msl ] add src  > playbacknet
[ msl ] add g    > playbacknet
[ msl ] add dest > playbacknet
[ msl ] updctrl playbacknet SoundFileSource/src/string/filename technomusic.au
[ msl ] run playbacknet
@end example 

The important thing to notice is that both the creation of MarSystems 
and their assembly into networks can be done at run-time without 
having to recompile any code. If anyone would like to pick 
a project to do for Marsyas it would be to use the GNU readline 
utility for it's commandline editing capabilities and try 
to come up with some alternative syntax (I have some ideas 
in that direction). 

@item @emph{distributed}
The subdirectory distributed contains sources and sinks that can 
be used to transmit sound and in general marsyas data over 
the network using TCP and UDP protocols. It enables cool 
thing like reading soundfiles on one computer sending fft 
frames for analysis to multiple computers and then 
assembling the results. The actual code has only be tested 
under Linux and is under construction so you at your own risk 
or even better fix the problems. 


@end enumerate


