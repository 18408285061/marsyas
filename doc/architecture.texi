@node Architecture concepts
@chapter Architecture concepts

In order to fully take advantage of the capabilities of Marsyas it is
important to understand how it works internally. The architecture of
Marsyas reflects an underlying dataflow model that we have found
useful in implementing real and non-real time audio analysis and
synthesis systems. In marsyas 0.2 a lot of things can be accomplished
by assembling complex networks of basic building blocks called
MarSystems that process data. This is the so
called @qq{Black-Box} functionality of the framework. In addition the
programmer can also write directly her/his own building blocks directly
in C++ following a certain API and coding conventions offering the so
called @qq{White-Box} functionality.  Building networks is described in
@ref{Writing applications}, and writing new MarSystems is described
in @ref{Programming MarSystems}.

@menu
* Architecture overview::       
* Implicit patching::           
* MarSystem composites::        
* Scheduling::                  
@end menu



@node Architecture overview, Implicit patching, Architecture concepts, Architecture concepts
@section Architecture overview

@menu
* Building MarSystems::         
* Dataflow model::              
@end menu


@node Building MarSystems, Dataflow model, Architecture overview, Architecture overview
@subsection Building MarSystems

The basic idea behind the design of Marsyas is that any audio
analysis/synthesis computation can be expressed as some type of
processing object, which we call MarSystem, that reads data from an
input slice of floating point numbers, performs some
computation/transformation based on data, and writes the results to
another slice of floating point numbers.  Networks of MarSystems can
be combined and encapsulated as one MarSystem.

For example consider an
audio processing series of computations consisting of reading samples
from a soundfile, performing an short-time fourier transform (STFT) to
calculate the complex spectrum, performing an inverse STFT to convert
back from the frequency domain to time domain, then applying a gain to
the amplitude of the samples and writing the result to a soundfile.

As is very frequently the case with audio processing networks objects
the input of each stage is the output of the previous stage.  This way
of assembling MarSystems is called a Series composite.  Once a Series
Composite is formed it can basically be used as one MarSystem that
does the whole thing. A figure showing a block diagram-like
presentation of this network is shown in the next section.


@node Dataflow model,  , Building MarSystems, Architecture overview
@subsection Dataflow model

Marsyas follows a dataflow model of audio computation.

@image{images/dataflow,,5cm}

Marsyas uses general matrices instead of 1-D arrays.  This allows
slices to be semantically correct.

@image{images/slices,,5cm}



@node Implicit patching, MarSystem composites, Architecture overview, Architecture concepts
@section Implicit patching

@menu
* Implicit patching vs. explicit patching::  
* Implicit patching advantages::  
* Patching example of Feature extraction::  
@end menu


@node Implicit patching vs. explicit patching, Implicit patching advantages, Implicit patching, Implicit patching
@subsection Implicit patching vs. explicit patching

Many audio analysis programs require the user to explicitly (manually)
connect every processing block,

@example
# EXPLICIT PATCHING: block definitions
source, F1, F2, F3, destination;
# connect the in/out ports of the blocks
connect(source, F1);
connect(source, F2);
connect(source, F3);
connect(F1, destination);
connect(F2, destination);
connect(F3, destination);
@end example

@image{images/explicit-patching,,4cm}

Marsyas uses @emph{implicit patching}: connections are made
automagically when blocks are created,

@example
# IMPLICIT PATCHING
source, F1, F2, F3, destination;
Fanout(F1, F2, F3);
Series(source, Fanout, destination);
@end example

@image{images/implicit-patching,,5cm}


@node Implicit patching advantages, Patching example of Feature extraction, Implicit patching vs. explicit patching, Implicit patching
@subsection Implicit patching advantages 

Creating a neural network with explicit patching soon becomes
a mess,

@image{images/neural-explicit,,5cm}

With implicit patching, this is much more manageable.

@example
# IMPLICIT PATCHING
fanoutLayer1(ANN_Node11, ..., ANN_Node1N);
...
fanoutLayerM(ANN_NodeM1, ..., ANN_NodeMN);
ANN_Series(fanoutLayer1, ..., fanoutLayerM);
@end example

@image{images/neural-implicit,,5cm}


Implicit patching can automagically adjust the connections without
requiring any code recompiliation.  For example, we can change
the number of bands in a filter bank without changing any code.

@image{images/implicit-filter-bank,,4cm}



@node Patching example of Feature extraction,  , Implicit patching advantages, Implicit patching
@subsection Patching example of Feature extraction

Suppose we wish to create a typical feature extraction program:

@image{images/feature-extraction,,5cm}

@example
MarSystemManager mng; 
MarSystem* Series1 = mng.create("Series", "Series1"); 
MarSystem* Fanout1 = mng.create("Fanout", "Fanout1"); 
MarSystem* Series2 = mng.create("Series", "Series2"); 
MarSystem* Fanout2 = mng.create("Fanout", "Fanout2"); 
MarSystem* Fanout3 = mng.create("Fanout", "Fanout3"); 
Fanout3->addMarSystem(mng.create("Mean", "Mean")); 
Fanout3->addMarSystem(mng.create("Variance", "Variance")); 
Fanout2->addMarSystem(mng.create("Centroid", "Centroid")); 
Fanout2->addMarSystem(mng.create("RollOff", "Rolloff")); 
Fanout2->addMarSystem(mng.create("Flux", "Flux");
Series2->addMarSystem(mng.create("Spectrum, "Spectrum"); 
Series2->addMarSystem(Fanout2); 
Fanout1->addMarSystem(mng.create("ZeroCrossings", "ZeroCrossings"); 
Fanout1->addMarSystem(Series2); 
Series1->addMarSystem(mng.create("SoundFileSource", "Source")); 
Series1->addMarSystem(Fanout1); 
Series1->addMarSystem(mng.create("Memory", "TextureMemory")); 
Series1->addMarSystem(Fanout3); 
Series1->addMarSystem(mng.create("classifier", "Classifier"));
@end example



@node MarSystem composites, Scheduling, Implicit patching, Architecture concepts
@section MarSystem composites

@WANTED{ descriptions of composites, add the other composites }


@menu
* Series::                      
* Parallel::                    
* Fanout::                      
* Accumulator::                 
@end menu


@node Series, Parallel, MarSystem composites, MarSystem composites
@subsection Series

@image{images/composite-series}


@node Parallel, Fanout, Series, MarSystem composites
@subsection Parallel

@image{images/composite-parallel}


@node Fanout, Accumulator, Parallel, MarSystem composites
@subsection Fanout

@image{images/composite-fanout}


@node Accumulator,  , Fanout, MarSystem composites
@subsection Accumulator

@image{images/composite-accumulator}


@node Scheduling,  , MarSystem composites, Architecture concepts
@section Scheduling

@menu
* Scheduling in Marsyas::       
* Components of the Marsyas Scheduler::  
@end menu

@node Scheduling in Marsyas, Components of the Marsyas Scheduler, Scheduling, Scheduling
@subsection Scheduling in Marsyas

Scheduling is the art of delaying actions (events) until later periods in time.
In Marsyas time and event are are more general than many other systems. This
allows for a wide range of user specified control rates and actions.

@subsubsection Time
Time is simply a counter. What it counts is up to the writer of a new timer
class. The two supplied timers, TmSampleCount and TmRealTime, count audio samples
and system micro-seconds respectively.

There are a number of issues surrounding control rates in Marsyas and most other
time-aware processing systems. Marsyas' primary task is to process audio data.
This data passes through the network in buffers of size N. Usually the network
is prompted to process the buffer of N samples by an outer loop. During
processing control of the network is lost as the buffer of data passes through
each MarSystem object. The scheduler checks for and dispatches events when the
network is ticked and before the buffer of data passes through the network.
Events are therefore dispatched at the start of each buffer processed.

Event dispatch is therefore governed by the audio sample rate. Ultimately every
custom timer bears some relation to the audio sample rate. Since events are
dispatched at the start of each tick, events are actually dispatched at a rate
of every N samples. This implies that there is a granularity on event dispatch
based on the sample rate and buffer size. If an event is to be dispatched at a
point in time that falls inside a buffer, ie at 256 for a buffer size of 512
samples, then that event will not be dispatched until the next buffer boundary
at which point its dispatch time will be <= current counter time.

We might wish to have sample accurate event timing. After all, there are other
audio processing systems that can claim the accuracy we might desire. The major
obstacle to achieving this accuracy is due to Marsyas' dataflow architecture.
When a buffer of N samples passes through the network it is processed multiple
times (normally once by each object in the network). This means that each sample
recurs a number of times equal to the number of Marsystems that process it.
More specifically, if the time is T when the network is ticked, then after the
first MarSystem processes the buffer of N samples time will be at T+N. The next
MarSystem will start processing the buffer at time T. In this way, time bounces
between T and T+N as the buffer passes through the network. This situation makes
it exceedingly difficult to make the network consistent for events that occur
between T and T+N. If a control value C is to be changed at time T+K where 0<K<N
then for C to remain consistent for all MarSystem objects that might be
interested then it must be changed to the previous state at the start of buffer
processing then to the new value at the event time - each time the buffer is
processed. This would be somewhat difficult and computationally expensive to
accomplish within the dataflow model. For this reason the scheduler only
dispatches events on buffer boundaries - when the network is ticked - as this is
the only point when all MarSystems are at the same point in time.

In many systems multiple control rates are desireable. Consider two timers based
on separate sample rates such as 44.1kHz and 12.34kHz. Since both of these rates
are regular, that is they repeat at a constant rate, then a simple conversion
function can be used to convert between the two rates. By converting one of the
rates to the other a single timer can be used in the scheduler. However for
other timers an errorless conversion function may not be possible. Consider a
control rate based on detecting someone tapping a drum stick. The rate of
tapping could be described as irregular because it is not known exactly when the
next tap will happen. Combining this timer with the audio sample rate creates
the problem that no perfect conversion function is possible that can compute
what the sample time will be for N taps in the future. In Marsyas this problem
is bypassed through the support of multiple timers. Events are therefore posted
on the timers they are specified on and no timer conversion takes place.

@subsubsection Event
An event is simply something that happens at some point in time. In Marsyas
an event is a class that contains a user-defined function. What this function
contains is up to the writer and can act on the Marsyas network or outside of
it. Marsyas is not threaded and neither is the scheduler so the scheduler will
wait for the event to complete its action before resuming. Be careful not to
do excessive processing during the dispatch of an event.

@node Components of the Marsyas Scheduler,  , Scheduling in Marsyas, Scheduling
@subsection Components of the Marsyas Scheduler

The scheduler is made up of a collection of files from those used by
the scheduler to those that support it. The classes directly related to
the scheduler along with their relationships is shown in
@xref{fig:asch1}.

@c @float Figure,fig:asch1
@c @image{images/scheduler-class-diagram}
@c @caption{Scheduler class diagram.}
@c @end float

@c @imgfigure{fig:asch1,Scheduler class diagram.,images/scheduler-class}
@float Figure, fig:asch1
@image{images/scheduler-class}
@caption{Scheduler class diagram.}
@end float

@subsubsection MarSystem
Each MarSystem object has its own scheduler. This makes it possbile to
post events on the MarSystem object directly. However, once a MarSystem
is contained within another (within a Composite) it no longer responds
to tick messages. This means that the schedulers in any of the contained
objects will remain dormant. Therefore the only operational scheduler in
a network is the one in the MarSystem being ticked.

Posting events on the scheduler is done through a number of
@code{updctrl} methods. Each one takes a @code{TmTime} class as its
first parameter.

@example
void @b{updctrl}(MarEvent* me);
void @b{updctrl}(TmTime t, MarEvent* ev);
void @b{updctrl}(TmTime t, Repeat rep, MarEvent* ev);
void @b{updctrl}(TmTime t, std::string cname, MarControlPtr control);
void @b{updctrl}(TmTime t, Repeat rep, std::string cname, MarControlPtr control);
@end example

Additional methods for adding and removing timers and discovering the
current time on a timer are available. The @code{updtimer} method is
provided to modify timer parameters at run-time.

@example
mrs_natural @b{getTime}(std::string timer_name);
void @b{updtimer}(std::string cname, TmControlValue value);
void @b{addTimer}(std::string class_name, std::string identifier);
void @b{addTimer}(TmTimer* t);
void @b{removeTimer}(std::string name);
@end example

@subsubsection Scheduler
It is the schedulers job to see that events are passed to the correct
timer when they are posted. On each network tick the scheduler prompts
each of the timers it manages to dispatch their pending events.

@subsubsection Timers
Timers define a control rate on which events may be scheduled. It is
also the job of the timer to manage a queue of events and dispatch them
at their scheduled dispatch time.

Creating a custom timer is simply a matter of defining its control rate,
its units (ie seconds), and implementing a function to count the elapsed
time between ticks. See the @file{TmSampleCount} timer as an example of
a custom timer.

@subsubsection Events
Events are the actions that happen at specified points in time. In
Marsyas events are split up between @file{MarEvent}, which encapsulates
the event action, and @file{ScheduledEvent} which associates a time with
the event. Custom events are constructed by inheriting from
@file{MarEvent} and overriding the @code{dispatch} and @code{clone}
methods.

The overridden @code{MarEvent::dispatch} method is where the custom
event action is defined. Since Marsyas is not threaded the network will
block during dispatch. This could result in breaks in audio for
real-time audio if the action takes too much time.

The @code{clone} method is used by @file{ScheduledEvent} to
copy the event. This is primarily to avoid confusion about who has
control over the event, the user or the scheduler, and who must delete
the event for proper memory management. A user who creates an event
using the keyword new and posts it must then delete it. The event will
have been copied by the @file{ScheduledEvent} object who will delete the
copy when appropriate. Without the @code{clone} method, if the user
deleted the event too early then a memory error may occur when the
deleted event is dispatched.

The @file{MarEvent} supports repetition without having to create new
events. The @code{set_repeat(Repeat r)} method takes a @file{Repeat}
object that defines how to repeat the event. The default behaviour is
no repetition. A true value from the @code{repeat()} method tells the
scheduler to repeat the event. This method queries the supplied
@file{Repeat} object. The @code{repeat_interval()} returns the repeat
rate. The @code{repeat_interval(string interval)} may be used to convert
the supplied interval to a count. It is used in the
@code{ScheduledEvent::doRepeat()} method.

@subsubsection Repeat
Repetition of events is defined using the @file{Repeat} class. This
class is simply a tuple of the repetition time interval and repetition
count. There are three ways to define repetition. @code{Repeat()}
defines no repetition. @code{Repeat(string interval)} defines an
infinite repetition at a rate specified by the supplied interval.
@code{Repeat(string interval, mrs_natural count)} defines a finite
repetition of count repeats to occur every interval.

Time is specified as a single string without a timer name. It is assumed
that the specified interval time will be meaningful on the timer that
the event is posted in.

@subsubsection TmTime
Time is specified using the @file{TmTime} class as
@code{TmTime(string timer, string time)}. The first parameter is the
name of the timer on which the second parameter has meaning. As an
example, @code{TmTime("TmSampleCount/Virtual","5s")} specifies 5 seconds
from the point of time it is used on the TmSampleCount timer called
Virtual.

@subsubsection TmTimerManager
Rather than instantiating timers and adding them to the scheduler using
the @code{MarSystem::addtimer(TmTimer* tmr)} method, timers may be
specified and added by name using the
@code{MarSystem::addtimer(string name, string ident)} method where name
is the timer name, ie TmSampleCount, and ident is the unique identifier,
ie Virtual. Of course, if the timer name is not known then this method
will fail. New timers can be added to the factory using the method
laid out in @file{TmTimerManager.cpp}. @xref{archtmrfac,,Timer Factory}.
@c @ref{Writing a new Timer,Timer Factory}.


