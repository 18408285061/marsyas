@node Automatic testing
@chapter Automatic testing

In an attempt to reduce the number of times we break working code,
we have added some testing mechanisms to Marsyas.

@menu
* Unit tests::                  
* Regression tests::            
* Daily Auto-tester::           
@end menu


@node Unit tests
@section Unit tests

These tests are highly focused on specific portions of code.

@menu
* Unit test infrastructure::    
@end menu

@node Unit test infrastructure
@subsection Unit test infrastructure

We use the unit test infrastucture provided by @code{cxxtest}.
These takes a @code{TestFoo.h} file and produces a
@code{Foo_runner.cpp} file which performs the actual test.

@WANTED{More description about this from sness}


@node Regression tests
@section Regression tests

These tests are deliberately simple and easy to understand.

@menu
* What does regression mean?::  
* How do the tests work?::      
* When a test fails...::        
* Why should I care?::          
@end menu

@node What does regression mean?
@subsection What does "regression" mean?

@unnumberedsubsubsec Definition

The term @qq{regression testing} seems to mean something different
to each project, website, and software engineering academic.  So I
shall define what we mean by @qq{regression testing} in the
context of Marsyas @qq{regression testing}:

@quotation
Does it work the way it used to?
@end quotation

This is checked as follows:

@enumerate
@item
Pick a program to test.  Find some input for the program (generally a
sound file).  Save the input.

@item
Run the program on the saved input.  Save the output (either another
sound file, or some text).

@item
Wait / change stuff / let other people change stuff.

@item
Run the program with the initial input.  Compare the current output to
the initially stored output.  If they are different, the test fails.

@item
Goto step 3.

@end enumerate

In other words, these tests do not check for @emph{correctness};
they simply check for @emph{consistency}.  Fixing a bug could
result in a test @qq{failing}.  However, this is not a problem:
see @ref{When a test fails...}


@node How do the tests work?
@subsection How do the tests work?

@unnumberedsubsubsec List of tests

Tests are defined in @file{src/tests/regression/CMakeLists.txt}.
Each test is split into two steps: creating an audio file, and
comparing that audio file to the previous (working) audio file.


@unnumberedsubsubsec Approximate matching (no rounding errors)

When an audio file is specified as an @qq{answer} file,

@example
audioCompare phasevoder.au ../output/right-phasevocoder.au
@end example

@noindent
we attempt to match the files approximately, to avoid rounding
mismatches on different operating systems.  Each sample must be
very close to the corresponding sample in the answer file, but
they need not be exact.


@node When a test fails...
@subsection When a test fails...

@unnumberedsubsubsec Don't panic!

If a test fails as a result of your work, remember that these are
@emph{consistency} tests, not @emph{correctness} tests.  Do you expect
your work to produce any different output for that particular test?

For example, if you discover (and fix) a bug in the inverse FFT, the
phasevocoder test will probably @qq{fail}.  This is to be expected: the
previously-recorded output of the phasevocoder faithfully archived the
buggy output, so the bug-free output is detected as different.

On the other hand, suppose you are adding a new classifier for machine
learning, and the Windowing test breaks.  This is not expected; a new
feature should not impact basic functions like taking a Hanning window!
In this case, you should investigate before committing your changes to
svn.

@unnumberedsubsubsec Updating the test

If you are certain that your patch (and new output file) are good, then
you should update the answer file.  This is simply a matter of copying
your new output file over the old answer file.

Please commit the changed
@file{src/tests/regressions/output/@emph{<FILE.au>}} in a separate
svn commit, and make sure the log message explains that your new
output is superior to the old one.

@unnumberedsubsubsec Temporarily disabling a test

If you are planning on doing a lot of work on part of Marsyas
(which would result in tests failing, but having no working output
yet), tests may be commented out in the
@file{src/tests/regressions/CMakeLists.txt} file.  Again, please
commit this change in a separate svn commit with a log message
that explains this.


@node Why should I care?
@subsection Why should I care?

@unnumberedsubsubsec Developers

Think of these tests as a mutual assistance pact: you should care
about not breaking other people's code, because other people will
care about not breaking @emph{your} code.

Of course, this requires that you create regression tests for your
own code.  Due to practicality, we can't check every single case
of every single program.  So instead, create one or two tests
which investigate as many things as possible.  For example,
instead of simply testing if sfplay can output a sound file, we
test changing the gain, starting at a specific time, and only
playing for a specific length.

We recommend discussing potential regression tests on the
developer mailist.

@unnumberedsubsubsec New users

These tests are also very useful if you start investigating a new
aspect of Marsyas.  Currently there are many unmaintained
MarSystems, applications, and projects in Marsyas.  New users can
easily waste hours trying to use part of the codebase which has
been broken for months.

Having a testing mechanism means that users know that the code is
working -- at least, working for the exact command and input that
the test uses.  If (when?) a user has problems getting something
to work in Marsyas, he can turn to the regtests: if a regtest
passes but his own code doesn't work, he can compare his code
against the regtest code.

Trust me, by now I've probably spent 20 hours trying to make
broken code to work -- sometimes when the developers already knew
it was broken!  Quite apart from the waste of time, it's
incredibly demoralizing.  It was this problem that inspired me to
create these tests.



@node Daily Auto-tester
@section Daily Auto-tester

We run the script

@example
scripts/dailytest.sh
@end example

@noindent
every day.  This script performs a few tasks:

@enumerate
@item
Exports a clean copy of the source tree from svn.

@item
Builds Marsyas.

@item
Runs the tests.

@item
Builds the documentation.

@end enumerate

An email is sent to some developers with the results of these
tests.  If you would like to receive these daily emails, please
enquire on the developer mailist.


