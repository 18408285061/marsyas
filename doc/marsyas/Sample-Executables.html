<html lang="en">
<head>
<title>Sample Executables - Marsyas 0.2</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marsyas 0.2">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Installation.html#Installation" title="Installation">
<link rel="next" href="Understanding-MarSystems-and-Composites.html#Understanding-MarSystems-and-Composites" title="Understanding MarSystems and Composites">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright 1998-2006 George Tzanetakis

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled "Copying" and "GNU General Public License"
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Sample-Executables"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Understanding-MarSystems-and-Composites.html#Understanding-MarSystems-and-Composites">Understanding MarSystems and Composites</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Installation.html#Installation">Installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">3 Sample Executables</h2>

<p>The main goal of Marsyas is to provide an extensible framework that
can be used to quickly design and experiment with audio analysis and
synthesis applications. It is important to realize that the goal is to
provide a framework for building applications rather than a set of
applications. The executables provided with the distribution, although
directly useful, are only only representative examples of what can be
achieved using the provided components.  They are also used as a
testbed to design/benchmark/experiment with the framework. Marsyas is
meant to be an extensible framework so making the effort of
understanding the code behind the executables is necessary for any
serious work. They also show the capabilities of Marsyas and serve as
pedagogical examples about how Marsyas primitives can used.

   <p>Marsyas executables operate either on individual soundfiles or
collections which are simple text files that contain lists of
soundfiles.

   <p>A simple way to create a collection is the unix ls command. 
For example:

<pre class="example">     &gt; ls /home/gtzan/data/sound/reggae/*.wav &gt; reggae.mf
</pre>
   <p>The collection will then look like as follows:
<pre class="example">     /home/gtzan/data/sound/reggae/foo.wav
     /home/gtzan/data/sound/reggae/bar.wav
</pre>
   <p>Any text editor or program that generates text can be used to create
collection files. The only constraint is that the name of the
collections file must have a .mf extension such as reggae.mf. Also any
line starting with the # character is ignored. For the Windows Visual
Studio version change the slash character separating directories
appropriately.

   <p>In addition, a simple commandline utility called mkcollection is
provided for easy creation of collections.  More information about
mkcollection is provided bellow.  Most executables operate on either
soundfiles or collections interchangeably.

   <p>The following executables are provided in marsyas:

     <ol type=1 start=1>

     <li><em>mkcollection</em>
<a name="index-mkcollection-11"></a>
mkcollection is a simple utility for creating collection
files. To create a collection of all the audio files residing
in a directory the following command can be used:

     <pre class="example">          &gt; mkcollection reggae.mf /home/gtzan/data/sound/
     </pre>
     <p>All the soundfiles residing in the directory provided by the second
argument will be added to the collection.  If there are subdirectories
mkcollection will recursively scan through. mkcollection only will add
files with .wav, .au extension but doesn't check that they are valid
soundfiles or that they are in one of the supported Marsyas
formats. mkcollection is not necessary for creating collections as
they can be created with any text editor or using ls. In general
collection files should contain soundfiles with the same sampling rate
as Marsyas doesn't perform automatic sampling conversion. The
exception to this rule is collection that mix files at 22050Hz and
44100Hz sampling rates in which case the 44100Hz files are downsampled
to 22050Hz. No implicit downsampling is performed to Collections that
contain only 44100Hz files.

     <li><em>sfplay</em>
<a name="index-sfplay-12"></a>
sfplay is a flexible command-line soundfile player that allows
playback of multiple soundfiles in various formats with either
real-time audio output or soundfile output. The following two example
show two extremes of using of sfplay: simple playback of foo.wav and
playing 3.2 seconds (-l) clips starting at 10.0 seconds (-s) into the
file and repeating the clips for 2.5 times (-r) writing the output to
output.wav (-f) at half volume (-g) playing each file in the
collection reggae.mf. The last command stores the MarSystem dataflow
network used in sfplay as a plugin in playback.mpl. The plugin is
essentially a textual description of the created network.  Because
MarSystems can be created at run-time the network can be loaded in a
sfplugin which is a generic executable that flows audio data through
any particular network.  Running sfplugin -p playback.mpl bar.wav will
play using the created plugin the file bar.wav. It is important to
note that although both sfplay and sfplugin have the same behavior in
this case they achieve it very different.  The main difference is that
in sfplay the network is created at compile time wheras in sfplugin
the network is created at run time.

     <pre class="example">          &gt; sfplay foo.wav
          &gt; sfplay -s 10.0 -l 3.2 -r 2.5 -g 0.5 foo.wav bar.au -f output.wav
          &gt; sfplay -l 3.0 reggae.mf
          &gt; sfplay foo.wav -p playback.mpl
     </pre>
     <li><em>sfplugin</em>
<a name="index-sfplugin-13"></a>
sfplugin is the universal executable. Any network of Marsystems
stored as a plugin can be loaded at run-time and sound can flow
through the network. The following example with appropriate plugins
will peform playback of foo.wav and playback with real time music
speech classification of foo.wav.

     <pre class="example">          &gt; sfplugin -p plugins/playback.mpl foo.wav
          &gt; sfplugin -p musp_classify.mpl foo.wav
     </pre>
     <li><em>sfinfo</em>
<a name="index-sfinfo-14"></a>
sfinfo is a simple command-line utility for displaying
information about a soundfile. It is also a simple
example of how printing out the controls can show
information like channels, sampling rate etc.

     <pre class="example">          &gt; sfinfo foo.wav
     </pre>
     <li><em>extract</em>

     <p>extract is a single-file executable for feature extraction. 
It can be used as part of external systems for feature
extraction therefore it outputs the results in a simple
tab-separated text file. For more serious feature extraction
over multiple files check bextract which is what I use most
of the time. It also serves as an example of a network
of MarSystems with relatively complicated structure. 
The following commands extract a single vector of features
based on the first 30 seconds of the provided
soundfile. By default the feature extractor is based on
extracting features based on the magnitude of the Short Time
Fourier Transform (STFT) (i.e means and variances of Spectral
Centroid, Rolloff, Flux). The second command extracts
the means and variances of Mel-Frequency Cepstral
Coefficients.

     <pre class="example">          &gt; extract foo.wav
          &gt; extract -e SVMFCC foo.wav
     </pre>
     <li><em>bextract</em>

     <p>bextract is one of the most powerful executables provided by
Marsyas. It can be used for complete feature extraction and
classification experiments with multiple files. It serves as a
canonical example of how audio analysis algorithms can be expressed in
the framework.

     <p>Suppose that you want to build a real-time music/speech descriminator
based on a collection of music files named music.mf and a collection
of speech files named speech.mf.  These collections can either be
created manually or using the mkcollection utility. The following
commandline will extract means and variances of Mel-Frequency cepstral
coefficients (MFCC) over a texture window of 1 sec.  The results are
stored in a wekaOut.arff which is a text file storing the feature
values that can be used in the Weka machine learning environment for
experimentation with different classifiers. At the same time that the
features are extracted, a simple Gaussian classifier is trained and
when feature extraction is completed the whole network of feature
extraction and classification is stored and can be used for real-time
audio classification directly as a Marsyas plugin.  The plugin makes a
classification decision every 20ms but aggregates the results by
majority voting to display output approximately every 1 second. The
whole network is stored in musp_classify.mpl which is loaded into
sfplugin and a new file named new.wav is passed through. The screen
output shows the classification results and confidence.

     <p>Users familiar with marsyas 0.1 will notice that currently the machine
learning part of marsyas 0.2 is not as sophisticated as the one of
0.1. For example there is no evaluate executable for performing
cross-validation experiments and the only classifier currently
implemented is a simple multidimensional Gaussian classifiar. For my
own research I have been increasingly using Weka for all the machine
learning experiments so porting this functionality to the new version
is not a high priority. On the other hand I have a clear notion of how
they can be integrated and most of the necessary components and APIs
are already in place. Eventually I would like to port most of Weka
into Marsyas but it will be some time until that happens.

     <pre class="example">          &gt; bextract -e STFT music.mf speech.mf -w wekaOut.arff -p musp_classify.mpl
          &gt; sfplugin -p musp_classify.mpl new.wav
     </pre>
     <p>Feature extractors that start with SV produce one value
for each value and can be used for non-realtime classification
such as genre classification. The following command can
be used to generate a weka file for genre classification.

     <pre class="example">          &gt; bextract -e SVSTFT classical.mf jazz.mf rock.mf -w genre.arff
     </pre>
     <p>Currently no classifier is generated for the SV feature extractors
but it's only a matter of time before this feature is added. 
The generated file genre.arff can the be loaded into Weka
where classification experiments can be conducted.

     <li><em>phasevocoder</em>
phasevocoder is probably the most powerful and canonical example of
sound synthesis provided currently by Marsyas. It is based on the
phasevocoder implementation described by F.R.Moore in his book
&ldquo;Elements of Computer Music&rdquo;. It is broken into individual
MarSystems in a modular way and can be used for real-time
pitch-shifting and time-scaling.

     <li><em>sftransform</em>
sftransform is an example of having a doubly nested
network with two FFT/inverse FFT identity transformations. 
It's not particularly useful but show how
to nested networks can be created.

     <li><em>pitchextract</em>
pitchextract is used to extract the fundamental frequency
contour from monophonic audio signals. A simple sinusoidal
playback is provided for playback of the resulting contour.

     <li><em>msl</em>

     <p>One of the most useful and powerful characteristics of Marsyas
is the ability to create and combine MarSystems at run time. 
msl (marsyas scripting language) is a simple interpreter
that can be used to create dataflow networks, adjust controls,
and run sound through the network. It's used as a backend for
user interfaces therefore it has limited (or more accurately
non-existent) editing functionality. The current syntax
is being revised so currently it's more a proof-of-concept. 
Here is an example of creating a simple network in msl and
playing a sound file:

     <pre class="example">          &gt;msl
          [ msl ] create Series playbacknet
          [ msl ] create SoundFileSource src
          [ msl ] create Gain g
          [ msl ] create AudioSink dest
          [ msl ] add src  &gt; playbacknet
          [ msl ] add g    &gt; playbacknet
          [ msl ] add dest &gt; playbacknet
          [ msl ] updctrl playbacknet SoundFileSource/src/string/filename technomusic.au
          [ msl ] run playbacknet
     </pre>
     <p>The important thing to notice is that both the creation of MarSystems
and their assembly into networks can be done at run-time without
having to recompile any code. If anyone would like to pick
a project to do for Marsyas it would be to use the GNU readline
utility for it's commandline editing capabilities and try
to come up with some alternative syntax (I have some ideas
in that direction).

     <li><em>distributed</em>
The subdirectory distributed contains sources and sinks that can
be used to transmit sound and in general marsyas data over
the network using TCP and UDP protocols. It enables cool
thing like reading soundfiles on one computer sending fft
frames for analysis to multiple computers and then
assembling the results. The actual code has only be tested
under Linux and is under construction so you at your own risk
or even better fix the problems.

        </ol>

   </body></html>

