@node Programming
@chapter Programming

@menu
* Assembling a network::        
* Writing your own MarSystems::  
@end menu


@node Assembling a network
@section Assembling a network

@menu
* Including libraries and linking::  
* Hello World (playing an audio file)::  
* Reading and altering controls::  
* Writing data to text files::  
* Getting data from the network::  
@end menu



@node Including libraries and linking
@subsection Including libraries and linking

@cindex Compiling
@cindex Linking
Unless you write your program inside the @file{marsyas/src} directory,
you need to include the Marsyas libraries in your project.


@unnumberedsubsubsec Linux and other *nixes

The easiest way to compile Marsyas projects is to use a makefile.  In your
working directory, create a file called @file{Makefile} which contains

@example
all:
	rm -f *.o
	g++ -Wall -O2 -I./ -I/usr/local/include/marsyas -c -o myfile.o myfile.cpp
	g++ -Lusr/local/lib -o myfile myfile.o -lmarsyas -lasound
@end example

@noindent
(place a tab in front of the three lower lines instead of spaces)

If you installed marsyas in a location other than @file{/usr/local/}, then
change the @code{-I} and @code{-L} directories accordingly.  For example,
if you installed marsyas in @file{$@{HOME@}/usr/}, then you would use
@code{-I$@{HOME@}/usr/include/marsyas} and @code{-L$@{HOME@}/usr/lib}.  Once
the @file{Makefile} is written, simply type @code{make} to compile
your file.




@unnumberedsubsubsec OSX

To compile Marsyas projects in OSX, use the same @file{Makefile} as is used
in other *nixes, but replace the final line with

@example
	g++ -Lusr/local/lib -o myfile myfile.o -lmarsyas -framework CoreAudio \
		-framework CoreMidi -framework CoreFoundation
@end example


@unnumberedsubsubsec Windows Visual Studio

Please see the documentation for your compiler / development environment.
@c alternately, Gustavo could write something here.  :)


@node Hello World (playing an audio file)
@subsection Hello World (playing an audio file)

@cindex Hello world
@cindex Playing an audio file

Instead of printing ``Hello World!'', we shall play a sound file.  This is
relatively straightforward: we create a @code{MarSystem} which is a
series of @code{SoundFileSource}, @code{Gain}, and @code{AudioSink}.  Once
the network is created and the controls are given, we call @code{tick()} to
make time pass until we have finished playing the file.


@verbatim
#include "MarSystemManager.h"
using namespace std;
using namespace Marsyas;

void sfplay(string sfName, float gain) {
  MarSystemManager mng;

  MarSystem* playbacknet = mng.create("Series", "playbacknet");

  playbacknet->addMarSystem(mng.create("SoundFileSource", "src"));
  playbacknet->addMarSystem(mng.create("Gain", "gt"));
  playbacknet->addMarSystem(mng.create("AudioSink", "dest"));

  playbacknet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
  playbacknet->updctrl("Gain/gt/mrs_real/gain", gain);
  playbacknet->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

  while ( playbacknet->getctrl("mrs_bool/notEmpty")->toBool() ) {
    playbacknet->tick();
  }
  delete playbacknet;
}

int main(int argc, const char **argv) {
  string fileName;
  float gain;
  if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else 
    { fileName = argv[1]; }
  if (argc<3) { gain = 1; } else
    { gain = atof(argv[2]); }
  cout << "Playing file " << fileName << " at volume " <<
    gain << endl;

  sfplay(fileName,gain);
  exit(0);
}
@end verbatim



@node Reading and altering controls
@subsection Reading and altering controls

Here we have modified the example from the previous section: we have added
the ability to start at an arbitrary position (time) inside the audio file.
To calculate the starting position in the file, we must know the sample rate
and number of channels.  We get this information from the
@code{SoundFileSource} with @code{getctrl}.


@verbatim
#include "MarSystemManager.h"
using namespace std;
using namespace Marsyas;

void sfplay(string sfName, float gain, float start) {
  MarSystemManager mng;

  MarSystem* playbacknet = mng.create("Series", "playbacknet");

  playbacknet->addMarSystem(mng.create("SoundFileSource", "src"));
  playbacknet->addMarSystem(mng.create("Gain", "gt"));
  playbacknet->addMarSystem(mng.create("AudioSink", "dest"));

// calculate the starting position.
  mrs_natural nChannels = playbacknet->getctrl("SoundFileSource/src/mrs_natural/nChannels")->toNatural();
  mrs_real srate = playbacknet->getctrl("SoundFileSource/src/mrs_real/israte")->toReal();
  mrs_natural startPosition = (mrs_natural) (start * srate * nChannels);

  playbacknet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
  playbacknet->updctrl("Gain/gt/mrs_real/gain", gain);
  playbacknet->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

// set the starting position of the source
  playbacknet->updctrl("SoundFileSource/src/mrs_natural/pos", startPosition);

  while ( playbacknet->getctrl("mrs_bool/notEmpty")->toBool() ) {
    playbacknet->tick();
  }
  delete playbacknet;
}

int main(int argc, const char **argv) {
  string fileName;
  float gain, start;
  if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else 
    { fileName = argv[1]; }
  if (argc<3) { gain = 1; } else
    { gain = atof(argv[2]); }
  if (argc<4) { start = 0; } else
    { start = atof(argv[3]); }
  cout << "Playing file " << fileName << " at volume " <<
    gain << " starting at " << start << " seconds" << endl;

  sfplay(fileName,gain,start);
  exit(0);
}
@end verbatim


@node Writing data to text files
@subsection Writing data to text files

Extract data from a network for further analysis (plotting,
other programs, etc) is fairly easy to do with @code{PlotSink}.

@verbatim
#include "MarSystemManager.h"
using namespace std;
using namespace Marsyas;

void recognize(string sfName) {
  MarSystemManager mng;
  MarSystem* pnet = mng.create("Series", "pnet");
// standard network
  pnet->addMarSystem(mng.create("SoundFileSource", "src"));
  pnet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
	pnet->addMarSystem(mng.create("Spectrum","spk"));

// add a PlotSink wherever we want to get data from
	pnet->addMarSystem(mng.create("PlotSink","plot"));
  pnet->updctrl("PlotSink/plot/mrs_string/outputFilename", "out");

  while ( pnet->getctrl("SoundFileSource/src/mrs_bool/notEmpty")->toBool() ) {
    pnet->tick();
  }
  delete pnet;
}

int main(int argc, const char **argv) {
  string fileName;
  if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else 
    { fileName = argv[1]; }
  cout << "Processing file " << fileName << endl;

  recognize(fileName);
  exit(0);
}
@end verbatim


@node Getting data from the network
@subsection Getting data from the network

Putting together a network of MarSystems is all well and good,
but you probably want to do something with that data.  In this
example we simply print it to the screen, but the important
thing to note is that we have the data at the level of C programming.

@verbatim
#include "MarSystemManager.h"
using namespace std;
using namespace Marsyas;

void recognize(string sfName) {
  MarSystemManager mng;
  MarSystem* pnet = mng.create("Series", "pnet");
// standard network
  pnet->addMarSystem(mng.create("SoundFileSource", "src"));
  pnet->updctrl("SoundFileSource/src/mrs_string/filename", sfName);
	pnet->addMarSystem(mng.create("Spectrum","spk"));

// variables to get data from network
  realvec in(pnet->getctrl("mrs_natural/inObservations")->toNatural(), pnet->getctrl("mrs_natural/inSamples")->toNatural());
	realvec out(pnet->getctrl("mrs_natural/onObservations")->toNatural(), pnet->getctrl("mrs_natural/onSamples")->toNatural());

// counter variables
	int i,j;
	mrs_natural numberObservations = pnet->getctrl("mrs_natural/onObservations")->toNatural();
	mrs_natural numberSamples = pnet->getctrl("mrs_natural/onSamples")->toNatural();

  while ( pnet->getctrl("SoundFileSource/src/mrs_bool/notEmpty")->toBool() ) {
    pnet->tick();
// get data from network
		pnet->process(in,out);

// display data
		for (i=0; i<numberObservations; i++) {
			for (j=0; j<numberSamples; j++) {
				cout<<out(i)(j)<<" ";
			}
		}
		cout<<endl;
  }
  delete pnet;
}

int main(int argc, const char **argv) {
  string fileName;
  if (argc<2) { cout<<"Please enter filename."<<endl; exit(1); } else 
    { fileName = argv[1]; }
  cout << "Processing file " << fileName << endl;

  recognize(fileName);
  exit(0);
}

@end verbatim




@node Writing your own MarSystems
@section Writing your own MarSystems

It's relatively straightforward to extend Marsyas by writing your own
Marsystems. As mentioned before each MarSystems must basically support
the process method that handles the dataflow and the update method
that handles the control messages.  There are certain conventions that
need to be followed so typically it is a better idea to copy and
modify an existing Marsystem rather than writing one from scratch. The
simple canonical example of a MarSystem that is what I use as a
template when I write a new Marsystem is Gain.h and Gain.cpp



