------------------------------ glwidget.cpp ------------------------------

GLuint GLWidget::makeObject()
{
    GLuint list = glGenLists(1);
    glNewList(list, GL_COMPILE);

    glBegin(GL_QUADS);

    GLdouble x1 = +0.06;
    GLdouble y1 = -0.14;
    GLdouble x2 = +0.14;
    GLdouble y2 = -0.06;
    GLdouble x3 = +0.08;
    GLdouble y3 = +0.00;
    GLdouble x4 = +0.30;
    GLdouble y4 = +0.22;

    quad(x1, y1, x2, y2, y2, x2, y1, x1);
    quad(x3, y3, x4, y4, y4, x4, y3, x3);

    extrude(x1, y1, x2, y2);
    extrude(x2, y2, y2, x2);
    extrude(y2, x2, y1, x1);
    extrude(y1, x1, x1, y1);
    extrude(x3, y3, x4, y4);
    extrude(x4, y4, y4, x4);
    extrude(y4, x4, y3, x3);

    const double Pi = 3.14159265358979323846;
    const int NumSectors = 200;

    for (int i = 0; i < NumSectors; ++i) {
        double angle1 = (i * 2 * Pi) / NumSectors;
        GLdouble x5 = 0.30 * sin(angle1);
        GLdouble y5 = 0.30 * cos(angle1);
        GLdouble x6 = 0.20 * sin(angle1);
        GLdouble y6 = 0.20 * cos(angle1);

        double angle2 = ((i + 1) * 2 * Pi) / NumSectors;
        GLdouble x7 = 0.20 * sin(angle2);
        GLdouble y7 = 0.20 * cos(angle2);
        GLdouble x8 = 0.30 * sin(angle2);
        GLdouble y8 = 0.30 * cos(angle2);

        quad(x5, y5, x6, y6, x7, y7, x8, y8);

        extrude(x6, y6, x7, y7);
        extrude(x8, y8, x5, y5);
    }

    glEnd();

    glEndList();
    return list;
}


void GLWidget::mousePressEvent(QMouseEvent *event)
{
  lastPos = event->pos();
}

void GLWidget::mouseMoveEvent(QMouseEvent *event)
{
  int dx = event->x() - lastPos.x();
  int dy = event->y() - lastPos.y();

  if (event->buttons() & Qt::LeftButton) {
	setXRotation(xRot + 8 * dy);
	setYRotation(yRot + 8 * dx);
  } else if (event->buttons() & Qt::RightButton) {
	setXRotation(xRot + 8 * dy);
	setZRotation(zRot + 8 * dx);
  }
  lastPos = event->pos();
}

------------------------------ glwidget.cpp ------------------------------

void GLWidget::mousePressEvent(QMouseEvent *event)
{
  lastPos = event->pos();
}

void GLWidget::mouseMoveEvent(QMouseEvent *event)
{
  int dx = event->x() - lastPos.x();
  int dy = event->y() - lastPos.y();

  if (event->buttons() & Qt::LeftButton) {
	setXRotation(xRot + 8 * dy);
	setYRotation(yRot + 8 * dx);
  } else if (event->buttons() & Qt::RightButton) {
	setXRotation(xRot + 8 * dy);
	setZRotation(zRot + 8 * dx);
  }
  lastPos = event->pos();
}


void GLWidget::quad(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2,
                    GLdouble x3, GLdouble y3, GLdouble x4, GLdouble y4)
{
  qglColor(trolltechGreen);

  glVertex3d(x1, y1, -0.05);
  glVertex3d(x2, y2, -0.05);
  glVertex3d(x3, y3, -0.05);
  glVertex3d(x4, y4, -0.05);

  glVertex3d(x4, y4, +0.05);
  glVertex3d(x3, y3, +0.05);
  glVertex3d(x2, y2, +0.05);
  glVertex3d(x1, y1, +0.05);
}

void GLWidget::extrude(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
  qglColor(trolltechGreen.dark(250 + int(100 * x1)));

  glVertex3d(x1, y1, +0.05);
  glVertex3d(x2, y2, +0.05);
  glVertex3d(x2, y2, -0.05);
  glVertex3d(x1, y1, -0.05);
}


------------------------------ window.cpp ------------------------------



  int i = 0;
  if (myfile.is_open()) {
	while (!myfile.eof() ) {
	  getline (myfile,line);
	  cout << line << endl;
	  ss.clear ();
	  ss.str ("");
	  ss << line;
	  ss >> in1 >> c >> in2 >> c >> in3;
	  cout << "fail=" << ss.fail() << " line=" << line << endl;
	  if (ss.fail())
		break;
	  vertices[i][0] = in1;
	  vertices[i][1] = in2;
	  vertices[i][2] = in3;
	  i++;
	}
	myfile.close();
  } else 
	cout << "Unable to open file";


------------------------------ glwidget.cpp ------------------------------

  glColor3fv(colors[0]);
  glBegin(GL_TRIANGLES);
  for (int i = 0; i < 8; i++) {
	glVertex3f(vertices[i][0]+0.0,vertices[i][1]+0.0,vertices[i][2]+0.0);
	glVertex3f(vertices[i][0]+0.1,vertices[i][1]+0.1,vertices[i][2]+0.0);
	glVertex3f(vertices[i][0]+0.1,vertices[i][1]-0.1,vertices[i][2]+0.0);
  }
  glEnd();


------------------------------ glwidget.cpp ------------------------------


  cout << "Creating playback network" << endl;

  // Create playback network
  pnet_ = mng.create("Series", "pnet_");
  pnet_->addMarSystem(mng.create("SoundFileSource", "src"));
//   pnet_->addMarSystem(mng.create("Gain", "gain"));
  pnet_->addMarSystem(mng.create("AudioSink", "dest"));
  pnet_->linkctrl("mrs_bool/notEmpty","SoundFileSource/src/mrs_bool/notEmpty");

  mwr_ = new MarSystemQtWrapper(pnet_);
  string infile = "./in_my_life.wav";
  pnet_->updctrl("SoundFileSource/src/mrs_string/filename",infile);

  mwr_->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

  mwr_->start();
  mwr_->play();
  cout << "Done creating playback network" << endl;
  

------------------------------ glwidget.cpp ------------------------------

  MarSystemManager mng;

   // create playback network with source-gain-dest
   MarSystem* playbacknet = mng.create("Series", "playbacknet");
   playbacknet->addMarSystem(mng.create("SoundFileSource", "src"));
   playbacknet->addMarSystem(mng.create("Gain", "gt"));
   playbacknet->addMarSystem(mng.create("AudioSink", "dest"));

   // Set the SoundFileName
   string inAudioFileName = "./in_my_life.wav";
   playbacknet->updctrl("SoundFileSource/src/mrs_string/filename",inAudioFileName);

   // Turn on the audio output
   playbacknet->updctrl("Gain/gt/mrs_real/gain", 1.0);
   playbacknet->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

   // link top-level controls 
   playbacknet->linkctrl("mrs_string/filename","SoundFileSource/src/mrs_string/filename");
   playbacknet->linkctrl("mrs_real/israte", "SoundFileSource/src/mrs_real/israte");
   playbacknet->linkctrl("mrs_natural/pos", "SoundFileSource/src/mrs_natural/pos");
   playbacknet->linkctrl("mrs_natural/loopPos", "SoundFileSource/src/mrs_natural/loopPos");
   playbacknet->linkctrl("mrs_bool/notEmpty", "SoundFileSource/src/mrs_bool/notEmpty");
   playbacknet->linkctrl("mrs_bool/initAudio", "AudioSink/dest/mrs_bool/initAudio");

    while (playbacknet->getctrl("SoundFileSource/src/mrs_bool/notEmpty")->isTrue())	{
	  playbacknet->tick();
	  cout << "tick" << endl;
    }


------------------------------ glwidget.cpp ------------------------------

#include <QtGui>
#include <QtOpenGL>
#include <QTimer>

#include <math.h>
#include <iostream>
#include <fstream>
#include <sstream>
using namespace std;

// Marsyas
#include "MarSystemManager.h"
#include "MarSystemQtWrapper.h"
using namespace MarsyasQt;


#include "glwidget.h"

// // The vertices for the cube
// GLfloat vertices[][3] = {
//   {-1.0, -1.0, 1.0}, 
//   {-1.0,  1.0,  1.0}, 
//   { 1.0,  1.0,  1.0}, 
//   { 1.0, -1.0,  1.0}, 
//   {-1.0, -1.0, -1.0}, 
//   {-1.0,  1.0, -1.0}, 
//   { 1.0,  1.0, -1.0}, 
//   { 1.0, -1.0, -1.0}};

// The colors for the faces of the cube
GLfloat colors[][3] = {
  { 0.0,  0.0,  0.0}, 
  { 0.0,  0.0,  1.0}, 
  { 0.0,  1.0,  0.0}, 
  { 0.0,  1.0,  1.0}, 
  { 1.0,  0.0,  0.0}, 
  { 1.0,  0.0,  1.0}};

GLWidget::GLWidget(QWidget *parent)
  : QGLWidget(parent)
{
  // Initialize member variables
  object = 0;
  xRot = 0;
  yRot = 0;
  zRot = 0;

  start_xRot = 0;
  start_yRot = 0;
  start_zRot = 0;

  end_xRot = 0;
  end_yRot = 0;
  end_zRot = 0;

  // Setup a timer
  timer = new QTimer(this);
  timerCount = 0;

  // Connect the timeout signal of the timer to a slot to do the timer rotation
  connect(timer, SIGNAL(timeout()), this, SLOT(doTimerRotate()));

  // The default rotation speed
  rotation_speed = 10;

  // Create space for the vertices we will display
  vertices = new GLfloat*[8];
  for (int i = 0; i < 8; i++) {
	vertices[i] = new GLfloat[3];
  }
  
  // Read in all the data from the text file
  ifstream myfile("in_box_vertices.txt");
  string line;
  stringstream ss;
  float in1, in2, in3;
  char c;

  int i = 0;
  if (myfile.is_open()) {
	while (!myfile.eof() ) {
	  getline (myfile,line);
	  cout << line << endl;
	  ss.clear ();
	  ss.str ("");
	  ss << line;
	  ss >> in1 >> c >> in2 >> c >> in3;
	  cout << "fail=" << ss.fail() << " line=" << line << endl;
	  if (ss.fail())
		break;
	  vertices[i][0] = in1;
	  vertices[i][1] = in2;
	  vertices[i][2] = in3;
	  i++;
	}
	myfile.close();
  } else 
	cout << "Unable to open file";
  
  //
  // Create the MarSystem
  // 

  cout << "Creating playback network" << endl;

  cout << "Creating playback network" << endl;

  // Create playback network
  pnet_ = mng.create("Series", "pnet_");
  pnet_->addMarSystem(mng.create("SoundFileSource", "src"));
//   pnet_->addMarSystem(mng.create("Gain", "gain"));
  pnet_->addMarSystem(mng.create("AudioSink", "dest"));
  pnet_->linkctrl("mrs_bool/notEmpty","SoundFileSource/src/mrs_bool/notEmpty");

  mwr_ = new MarSystemQtWrapper(pnet_);
  string infile = "./in_my_life.wav";
  pnet_->updctrl("SoundFileSource/src/mrs_string/filename",infile);

  mwr_->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

  mwr_->start();
  mwr_->play();
  cout << "Done creating playback network" << endl;

  // The animation timer
  QTimer *timer = new QTimer( this ); 
  //this creates a Qt timer event
   connect( timer, SIGNAL(timeout()), this, SLOT(animate()) ); 
  //this specifies what is to happen when the timer sends
  //  a signal, ie, when the timer event occurs
  //  (SIGNAL(timeout)) send a signal to
  //  SLOT(animate()) - which is in glbox.cpp 
  timer->start(50);
  //this specifies that the timer event happens every 4
  //   milliseconds and that it is infinite loop


  
  
}

GLWidget::~GLWidget()
{
  makeCurrent();
  glDeleteLists(object, 1);
}

// The minimum size of the widget
QSize GLWidget::minimumSizeHint() const
{
  return QSize(50, 50);
}

// The maximum size of the widget
QSize GLWidget::sizeHint() const
{
  return QSize(400, 400);
}

// Set the x rotation angle
void GLWidget::setXRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != xRot) {
	xRot = angle;
	emit xRotationChanged(angle);
	updateGL();
  }
}

// Set the y rotation angle
void GLWidget::setYRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != yRot) {
	yRot = angle;
	emit yRotationChanged(angle);
	updateGL();
  }
}

// Set the z rotation angle
void GLWidget::setZRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != zRot) {
	zRot = angle;
	emit zRotationChanged(angle);
	updateGL();
  }
}

// Initialize the GL widget
void GLWidget::initializeGL()
{
  // Set the background color to white
  qglClearColor(Qt::white);

  // Construct the object
  object = makeObject();
  
  // Set the shading model to GL_FLAT
  glShadeModel(GL_FLAT);
  
  // Enable depth testing
  glEnable(GL_DEPTH_TEST);

  // Cull the faces that face backwards
  glEnable(GL_CULL_FACE);
}

// Paint the GL widget
void GLWidget::paintGL()
{
  // Clear the color and depth buffer
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
  // Load the identity matrix
  glLoadIdentity();

  // Translate the model to 0,0,-10
  glTranslated(0.0, 0.0, -10.0);

  // Rotate the object around the x,y,z axis
  glRotated(xRot / 16.0, 1.0, 0.0, 0.0);
  glRotated(yRot / 16.0, 0.0, 1.0, 0.0);
  glRotated(zRot / 16.0, 0.0, 0.0, 1.0);

  // Draw the object
  redrawObject();
  
   cout << "redrawing" << endl;
//   mwr_->play();
//   cout << mwr_->getctrl("mrs_realvec/processedData")->to<mrs_realvec>() << endl;


}

void GLWidget::animate() {
   cout << "animate" << endl;
   emit updateGL();

}

void GLWidget::redrawObject() {
  mrs_realvec data = mwr_->getctrl("mrs_realvec/processedData")->to<mrs_realvec>();

  cout << "data(0,0)=" << data(0,0) << endl;

  glColor3fv(colors[0]);
  glBegin(GL_LINE_STRIP);
  for (int i = 0; i < data.getCols(); i++) {
 	glVertex3f(i/10.0,data(0,i),0);
  }
  glEnd();

}

// Resize the window
void GLWidget::resizeGL(int width, int height)
{
  // The smallest side of the window
  int side = qMin(width, height);

  // Setup the glViewport
  glViewport((width - side) / 2, (height - side) / 2, side, side);

  // Switch to GL_PROJECTION matrix mode
  glMatrixMode(GL_PROJECTION);

  // Load the identity matrix
  glLoadIdentity();

  // Setup an orthographic viewing system
  glOrtho(-2.0, +2.0, +2.0, -2.0, 4.0, 15.0);

  // Switch back to GL_MODELVIEW mode
  glMatrixMode(GL_MODELVIEW);
}

// Draw a face of the cube
void GLWidget::drawCubeFace(int a, int b, int c, int d) {
  // Start drawing the object
  glBegin(GL_POLYGON);

  // Draw the vertices of the cube
  glVertex3fv(vertices[a]);
  glVertex3fv(vertices[b]);
  glVertex3fv(vertices[c]);
  glVertex3fv(vertices[d]);

  // End drawing the object
  glEnd();
}

// Make the cube object
GLuint GLWidget::makeObject()
{
  // Make a new display list
  GLuint list = glGenLists(1);
  glNewList(list, GL_COMPILE);

  // Draw and color each face of the cube
//   glColor3fv(colors[0]);
//   draw_cube_face(0,3,2,1);
//   glColor3fv(colors[2]);
//   draw_cube_face(2,3,7,6);
//   glColor3fv(colors[3]);
//   draw_cube_face(3,0,4,7);
//   glColor3fv(colors[1]);
//   draw_cube_face(1,2,6,5);
//   glColor3fv(colors[4]);
//   draw_cube_face(4,5,6,7);
//   glColor3fv(colors[5]);
//   draw_cube_face(5,4,0,1);

  glColor3fv(colors[0]);
  glBegin(GL_TRIANGLES);
  for (int i = 0; i < 8; i++) {
 	glVertex3f(vertices[i][0]+0.0,vertices[i][1]+0.0,vertices[i][2]+0.0);
	glVertex3f(vertices[i][0]+0.05,vertices[i][1]+0.05,vertices[i][2]+0.0);
	glVertex3f(vertices[i][0]+0.05,vertices[i][1]-0.05,vertices[i][2]+0.0);
  }
  glEnd();

  

  glEndList();
  return list;
}

// Normalize an angle
void GLWidget::normalizeAngle(int *angle)
{
  while (*angle < 0)
	*angle += 360 * 16;
  while (*angle > 360 * 16)
	*angle -= 360 * 16;
}

// Set the start x rotation value
void GLWidget::setStartXRotation(int angle)
{
  normalizeAngle(&angle);
  start_xRot = angle;
}

// Set the start y rotation value
void GLWidget::setStartYRotation(int angle)
{
  normalizeAngle(&angle);
  start_yRot = angle;
}

// Set the start z rotation value
void GLWidget::setStartZRotation(int angle)
{
  normalizeAngle(&angle);
  start_zRot = angle;
}

// Set the end x rotation value
void GLWidget::setEndXRotation(int angle)
{
  normalizeAngle(&angle);
  end_xRot = angle;
}

// Set the end y rotation value
void GLWidget::setEndYRotation(int angle)
{
  normalizeAngle(&angle);
  end_yRot = angle;
}

// Set the end z rotation value
void GLWidget::setEndZRotation(int angle)
{
  normalizeAngle(&angle);
  end_zRot = angle;
}

// Start the animation timer
void GLWidget::startTimerRotate()
{
  // If we are already doing an animation, just return
  if (timer->isActive())
	return;

  // Start the timer, with the timeout of the timer being the rotation
  // speed
  timer->start(rotation_speed);

  // Initialize the counter for how many steps we are through the
  // animation
  timerCount = 0;
}

// Do one click of the animation timer
void GLWidget::doTimerRotate() 
{
  // Increment the animation steps
  ++timerCount;

  // If we've done the required number of steps, stop the animation timer
  if (timerCount >= TIMER_COUNT_STEPS)
	timer->stop();

  // Emit a signal to say that the number of animation steps has changed
  emit timerChanged(timerCount);

  // Linearly interpolate the values for the x,y,z rotation values and
  // emit signals for them
  int x = start_xRot + ((timerCount / TIMER_COUNT_STEPS) * end_xRot);
  int y = start_yRot + ((timerCount / TIMER_COUNT_STEPS) * end_yRot);
  int z = start_zRot + ((timerCount / TIMER_COUNT_STEPS) * end_zRot);

  // Set the x,y,z rotation angles
  setXRotation(x);
  setYRotation(y);
  setZRotation(z);

}

// Set the rotation speed
void GLWidget::setRotationSpeed(int speed)
{
  rotation_speed = speed;
}




------------------------------ glwidget.cpp ------------------------------
  // Create space for the vertices we will display
  vertices = new GLfloat*[8];
  for (int i = 0; i < 8; i++) {
	vertices[i] = new GLfloat[3];
  }
  
  // Read in all the data from the text file
  ifstream myfile("in_box_vertices.txt");
  string line;
  stringstream ss;
  float in1, in2, in3;
  char c;

  int i = 0;
  if (myfile.is_open()) {
	while (!myfile.eof() ) {
	  getline (myfile,line);
	  cout << line << endl;
	  ss.clear ();
	  ss.str ("");
	  ss << line;
	  ss >> in1 >> c >> in2 >> c >> in3;
	  cout << "fail=" << ss.fail() << " line=" << line << endl;
	  if (ss.fail())
		break;
	  vertices[i][0] = in1;
	  vertices[i][1] = in2;
	  vertices[i][2] = in3;
	  i++;
	}
	myfile.close();
  } else 
	cout << "Unable to open file";


------------------------------ glwidget.cpp ------------------------------

void GLWidget::redrawObject() {

  glColor3fv(colors[0]);
  glBegin(GL_LINE_STRIP);
  for (int i = 0; i < data.getRows(); i++) {
	for (int j = 0; j < data.getRows(); j++) {
// 	cout << "x=" << i/10.0 << " y=" << data(i,0) << endl;
 	glVertex3f(i/10.0,-1.0*data(i,0)*100.0,0);
  }
  glEnd();

}


------------------------------ glwidget.cpp ------------------------------

void GLWidget::animate() {
//    cout << "animate" << endl;
  addDataToRingBuffer();
  emit updateGL();

}

void GLWidget::addDataToRingBuffer() {
  ring_buffer_pos += 1;
  if (ring_buffer_pos >= MAX_SPECTRUM_LINES) {
	ring_buffer_pos = 0;
  }

  mrs_realvec data = mwr_->getctrl("Parallel/stereobranches/Series/left/PowerSpectrum/leftpspk/mrs_realvec/processedData")->to<mrs_realvec>();


  for (int i = 0; i < SPECTRUM_SIZE; i++) {
	spectrum_ring_buffer[ring_buffer_pos][i] = data(i,0);
  }
  

}

void GLWidget::redrawObject() {

  glColor3fv(colors[0]);
  for (int i = 0; i < MAX_SPECTRUM_LINES; i++) {
	glBegin(GL_LINE_STRIP);
	for (int j = 0; j < SPECTRUM_SIZE; j++) {
	  // 	cout << "x=" << i/10.0 << " y=" << data(i,0) << endl;
	  float x = (j - SPECTRUM_SIZE / 2.0) / 100.0;
	  float y = 100.0 * spectrum_ring_buffer[ring_buffer_pos][j];
	  float z = i;
	  glVertex3f(x,y,z);
	}
	glEnd();
  }

}


------------------------------ glwidget.cpp ------------------------------


// Set the test x rotation value
void GLWidget::setTestX(int val)
{
  float f = -1 * val;
  cout << "x=" << val << " f=" << f << endl;
  glFogf(GL_FOG_START, f);// Fog Start Depth
  glEnable(GL_FOG);// Enables GL_FOG
}

// Set the test y rotation value
void GLWidget::setTestY(int val)
{
  float f = -1 * val;
  cout << "y=" << val << " f=" << f << endl;
  glFogf(GL_FOG_END, f);// Fog Start Depth
  glEnable(GL_FOG);// Enables GL_FOG
}

// Set the test z rotation value
void GLWidget::setTestZ(int val)
{
  cout << "z=" << val << endl;
}

------------------------------ glwidget.cpp ------------------------------

glColor3f(1,1,1);
  // sness - These positions were determined empirically by moving                                                             
  // text around on the screen.  It would be nice to figure out how to                                                         
  // do this more automatically. The corners are: top=2.85 bottom=0                                                            
  // left=-1.5 right=1.5                                                                                                       
  glRasterPos3f(-1.5,2.85,49);
  string str = "test123";
  for(int i = 0; i < 7; i++) {
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, str.at(i));
  }


------------------------------ CMakeLists.txt ------------------------------ 

INCLUDE_DIRECTORIES(${QT_QTOPENGL_INCLUDE_DIR} ${GLUT_INCLUDE_DIR})
set(LIBS ${LIBS} ${GLUT_LIBRARIES})


------------------------------ glwidget.cpp ------------------------------

#include <QtGui>
#include <QtOpenGL>
#include <QTimer>

#include <math.h>
#include <iostream>
#include <fstream>
#include <sstream>
using namespace std;

// Marsyas
#include "MarSystemManager.h"
#include "MarSystemQtWrapper.h"
using namespace MarsyasQt;

#include "glwidget.h"

GLWidget::GLWidget(string inAudioFileName, QWidget *parent)
  : QGLWidget(parent)
{
  // Initialize member variables
  xRot = 30;
  yRot = 0;
  zRot = 0;
  test_x = 0;
  test_y = 0;
  test_z = 0;

  // Defaults
  rotation_speed = 10;
  y_scale = 350;

  // Allocate space for the ring buffer used to draw the spectrum
  spectrum_ring_buffer = new double*[MAX_SPECTRUM_LINES];
  for (int i = 0; i < MAX_SPECTRUM_LINES; i++) {
	spectrum_ring_buffer[i] = new double[SPECTRUM_SIZE];
	for (int j = 0; j < SPECTRUM_SIZE; j++) {
	  spectrum_ring_buffer[i][j] = 0.0;
	}
  }
  ring_buffer_pos = 0;
  
  //
  // Create the MarSystem to play and analyze the data
  // 
  MarSystemManager mng;

  MarSystem* net = mng.create("Series", "net");
  net->addMarSystem(mng.create("SoundFileSource", "src"));
  net->addMarSystem(mng.create("AudioSink", "dest"));
	
  MarSystem* stereobranches = mng.create("Parallel", "stereobranches");
  MarSystem* left = mng.create("Series", "left");
  MarSystem* right = mng.create("Series", "right");

  left->addMarSystem(mng.create("Windowing", "hamleft"));
  left->addMarSystem(mng.create("Spectrum", "spkleft"));
  left->addMarSystem(mng.create("PowerSpectrum", "leftpspk"));
  left->addMarSystem(mng.create("Gain", "leftgain"));

  right->addMarSystem(mng.create("Windowing", "hamright"));
  right->addMarSystem(mng.create("Spectrum", "spkright"));
  right->addMarSystem(mng.create("PowerSpectrum", "rightpspk"));
  right->addMarSystem(mng.create("Gain", "rightgain"));

  stereobranches->addMarSystem(left);
  stereobranches->addMarSystem(right);

  net->addMarSystem(stereobranches);

  net->addMarSystem(mng.create("StereoSpectrum", "sspk"));

  net->updctrl("SoundFileSource/src/mrs_string/filename",inAudioFileName);
  net->updctrl("SoundFileSource/src/mrs_real/repetitions",-1.0);

  //net->updctrl("mrs_real/israte", 44100.0);
  net->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

  // Create and start playing the MarSystemQtWrapper that wraps
  // Marsyas in a Qt thread
  mwr_ = new MarSystemQtWrapper(net);
  mwr_->start();
  mwr_->play();

  //   cout << "Creating playback network" << endl;

  //   cout << "Creating playback network" << endl;

  //   // Create playback network
  //   pnet_ = mng.create("Series", "pnet_");
  //   pnet_->addMarSystem(mng.create("SoundFileSource", "src"));
  // //   pnet_->addMarSystem(mng.create("Gain", "gain"));
  //   pnet_->addMarSystem(mng.create("AudioSink", "dest"));
  //   pnet_->linkctrl("mrs_bool/notEmpty","SoundFileSource/src/mrs_bool/notEmpty");

  //   mwr_ = new MarSystemQtWrapper(pnet_);
  //   string infile = "./in_my_life.wav";
  //   pnet_->updctrl("SoundFileSource/src/mrs_string/filename",infile);

  //   mwr_->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

  //   mwr_->start();
  //   mwr_->play();
  //   cout << "Done creating playback network" << endl;



  // The animation timer
  QTimer *timer = new QTimer( this ); 
  //this creates a Qt timer event
  connect( timer, SIGNAL(timeout()), this, SLOT(animate()) ); 
  //this specifies what is to happen when the timer sends
  //  a signal, ie, when the timer event occurs
  //  (SIGNAL(timeout)) send a signal to
  //  SLOT(animate()) - which is in glbox.cpp 
  timer->start(10);
  //this specifies that the timer event happens every 4
  //   milliseconds and that it is infinite loop
  
}

GLWidget::~GLWidget()
{
  makeCurrent();
  glDeleteLists(object, 1);
}

// The minimum size of the widget
QSize GLWidget::minimumSizeHint() const
{
  return QSize(400, 400);
}

// The maximum size of the widget
QSize GLWidget::sizeHint() const
{
  return QSize(600, 600);
}

// Set the x rotation angle
void GLWidget::setXRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != xRot) {
	xRot = angle;
	emit xRotationChanged(angle);
	updateGL();
  }
}

// Set the y rotation angle
void GLWidget::setYRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != yRot) {
	yRot = angle;
	emit yRotationChanged(angle);
	updateGL();
  }
}

// Set the z rotation angle
void GLWidget::setZRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != zRot) {
	zRot = angle;
	emit zRotationChanged(angle);
	updateGL();
  }
}

// Initialize the GL widget
void GLWidget::initializeGL()
{
  // Set the background color to white
  qglClearColor(Qt::black);

  // Set the shading model
  glShadeModel(GL_SMOOTH);
  
  // Enable depth testing
  glEnable(GL_DEPTH_TEST);

  // 
  // Enable fog based depth cueing
  //
  GLfloat fogColor[4]= {0.0f, 0.0f, 0.0f, 1.0f};

  glClearColor(0.0f,0.0f,0.0f,1.0f);// We'll Clear To The Color Of The Fog ( Modified )

  glFogi(GL_FOG_MODE, GL_EXP2);// Fog Mode (GL_EXP, GL_EXP2, GL_LINEAR)
  glFogfv(GL_FOG_COLOR, fogColor);// Set Fog Color
  glFogf(GL_FOG_DENSITY, 0.02f);// How Dense Will The Fog Be
  //    glHint;// Fog Hint Value
  glHint(GL_FOG_HINT, GL_NICEST);// Fog Hint Value(GL_DONT_CARE, GL_NICEST)
  glFogf(GL_FOG_START, 0.1f);// Fog Start Depth
  glFogf(GL_FOG_END, 0.2f);// Fog End Depth
  glEnable(GL_FOG);// Enables GL_FOG

  //
  // Antialias lines
  //
  glEnable(GL_LINE_SMOOTH);
  glHint (GL_LINE_SMOOTH_HINT,GL_NICEST);
}

// Paint the GL widget
void GLWidget::paintGL()
{
  // Clear the color and depth buffer
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
  // Load the identity matrix
  glLoadIdentity();

  // Translate the model to 0,0,-10
  glTranslated(0.0, 0.0, -29.0);

  // Rotate the object around the x,y,z axis
  glRotated(xRot / 16.0, 1.0, 0.0, 0.0);
  glRotated(yRot / 16.0, 0.0, 1.0, 0.0);
  glRotated(zRot / 16.0, 0.0, 0.0, 1.0);

  glTranslated(0.0, -0.75, -29.0);

  // Draw the object
  redrawObject();
  
  //    cout << "redrawing" << endl;
  //   mwr_->play();
  //   cout << mwr_->getctrl("mrs_realvec/processedData")->to<mrs_realvec>() << endl;


}

void GLWidget::animate() {
  //    cout << "animate" << endl;
  emit updateGL();
  addDataToRingBuffer();

}

void GLWidget::addDataToRingBuffer() {
  mrs_realvec data = mwr_->getctrl("Parallel/stereobranches/Series/left/PowerSpectrum/leftpspk/mrs_realvec/processedData")->to<mrs_realvec>();

  for (int i = 0; i < SPECTRUM_SIZE; i++) {
	spectrum_ring_buffer[ring_buffer_pos][i] = data(i,0);
  }
  
  //   cout << "ring_buffer_pos=" << ring_buffer_pos << endl;

  ring_buffer_pos += 1;
  if (ring_buffer_pos >= MAX_SPECTRUM_LINES) {
	ring_buffer_pos = 0;
  }


}

void GLWidget::redrawObject() {

  for (int i = 0; i < MAX_SPECTRUM_LINES; i++) {
	glColor3f((i / (float)MAX_SPECTRUM_LINES),1,0);
 	//glColor3fv(colors[i % 6]);

	glBegin(GL_LINE_STRIP);
	for (int j = 0; j < SPECTRUM_SIZE; j++) {
	  // sness - The 70 and 350 below were empirically chosen to fit on the screen
	  float x = (j - SPECTRUM_SIZE / 2.0) / 40.0;
	  // 	  float y = 350 * spectrum_ring_buffer[(i + ring_buffer_pos) % MAX_SPECTRUM_LINES][j];
	  float y = y_scale * spectrum_ring_buffer[(i + ring_buffer_pos) % MAX_SPECTRUM_LINES][j];
 	  float z = i;
	  glVertex3f(x,y,z);
	}
	glEnd();
  }

}

// Resize the window
void GLWidget::resizeGL(int width, int height)
{
  // The smallest side of the window
  int side = qMin(width, height);

  // Setup the glViewport
  glViewport((width - side) / 2, (height - side) / 2, side, side);

  // Switch to GL_PROJECTION matrix mode
  glMatrixMode(GL_PROJECTION);

  // Load the identity matrix
  glLoadIdentity();

  // Setup an orthographic viewing system
  //   glOrtho(-2.0, +2.0, +2.0, -2.0, 4.0, 15.0);
  //   gluPerspective(30,1,0.1,1000);
  gluPerspective(20,1,0.1,1000);

  // Switch back to GL_MODELVIEW mode
  glMatrixMode(GL_MODELVIEW);
}

// Draw a face of the cube
void GLWidget::drawCubeFace(int a, int b, int c, int d) {
  // Start drawing the object
  glBegin(GL_POLYGON);

  // Draw the vertices of the cube
  glVertex3fv(vertices[a]);
  glVertex3fv(vertices[b]);
  glVertex3fv(vertices[c]);
  glVertex3fv(vertices[d]);

  // End drawing the object
  glEnd();
}

// Make the cube object
GLuint GLWidget::makeObject()
{
  // Make a new display list
  GLuint list = glGenLists(1);
  glNewList(list, GL_COMPILE);

  // Draw and color each face of the cube
  //   glColor3fv(colors[0]);
  //   draw_cube_face(0,3,2,1);
  //   glColor3fv(colors[2]);
  //   draw_cube_face(2,3,7,6);
  //   glColor3fv(colors[3]);
  //   draw_cube_face(3,0,4,7);
  //   glColor3fv(colors[1]);
  //   draw_cube_face(1,2,6,5);
  //   glColor3fv(colors[4]);
  //   draw_cube_face(4,5,6,7);
  //   glColor3fv(colors[5]);
  //   draw_cube_face(5,4,0,1);

  //   glColor3fv(colors[0]);
  //   glBegin(GL_TRIANGLES);
  //   for (int i = 0; i < 8; i++) {
  //  	glVertex3f(vertices[i][0]+0.0,vertices[i][1]+0.0,vertices[i][2]+0.0);
  // 	glVertex3f(vertices[i][0]+0.05,vertices[i][1]+0.05,vertices[i][2]+0.0);
  // 	glVertex3f(vertices[i][0]+0.05,vertices[i][1]-0.05,vertices[i][2]+0.0);
  //   }
  //   glEnd();

  

  glEndList();
  return list;
}

// Normalize an angle
void GLWidget::normalizeAngle(int *angle)
{
  while (*angle < 0)
	*angle += 360 * 16;
  while (*angle > 360 * 16)
	*angle -= 360 * 16;
}

// // Set the end x rotation value
// void GLWidget::setEndXRotation(int angle)
// {
//   normalizeAngle(&angle);
//   end_xRot = angle;
// }

// // Set the end y rotation value
// void GLWidget::setEndYRotation(int angle)
// {
//   normalizeAngle(&angle);
//   end_yRot = angle;
// }

// // Set the end z rotation value
// void GLWidget::setEndZRotation(int angle)
// {
//   normalizeAngle(&angle);
//   end_zRot = angle;
// }

// // Start the animation timer
// void GLWidget::startTimerRotate()
// {
//   // If we are already doing an animation, just return
//   if (timer->isActive())
// 	return;

//   // Start the timer, with the timeout of the timer being the rotation
//   // speed
//   timer->start(rotation_speed);

//   // Initialize the counter for how many steps we are through the
//   // animation
//   timerCount = 0;
// }

// // Do one click of the animation timer
// void GLWidget::doTimerRotate() 
// {
//   // Increment the animation steps
//   ++timerCount;

//   // If we've done the required number of steps, stop the animation timer
//   if (timerCount >= TIMER_COUNT_STEPS)
// 	timer->stop();

//   // Emit a signal to say that the number of animation steps has changed
//   emit timerChanged(timerCount);

//   // Linearly interpolate the values for the x,y,z rotation values and
//   // emit signals for them
//   int x = start_xRot + ((timerCount / TIMER_COUNT_STEPS) * end_xRot);
//   int y = start_yRot + ((timerCount / TIMER_COUNT_STEPS) * end_yRot);
//   int z = start_zRot + ((timerCount / TIMER_COUNT_STEPS) * end_zRot);

//   // Set the x,y,z rotation angles
//   setXRotation(x);
//   setYRotation(y);
//   setZRotation(z);

// }

// // Set the rotation speed
// void GLWidget::setRotationSpeed(int speed)
// {
//   rotation_speed = speed;
// }



// void GLWidget::playSong() {
// }

// Set the test z rotation value
void GLWidget::setYScale(int scale)
{
  y_scale = scale;
  cout << "y_scale=" << y_scale << endl;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


// Set the test x rotation value
void GLWidget::setTestX(int val)
{
  //   test_x = 5 - (val / 10);
  test_x = 5.0 - (val / 20.0);
  cout << "x :: val=" << val << " x=" << test_x << endl;
}

// Set the test y rotation value
void GLWidget::setTestY(int val)
{
  test_y = 5.0 - (val / 20.0);
  cout << "y :: val=" << val << " y=" << test_y << endl;
}

// Set the test z rotation value
void GLWidget::setTestZ(int val)
{
  test_z = val;
  cout << "z :: val=" << val << " z=" << test_z << endl;
}



------------------------------ glwidget.cpp ------------------------------

** Fri Jun 19 2009 - 11:10:29 AM
   -----------------------------

Original waveformnet, which doesn't work because the output realvecs
of the two MarSystems are different

  //
  // Create the MarSystem to play and analyze the data
  // 
  MarSystemManager mng;

  MarSystem* net = mng.create("Series", "net");
  net->addMarSystem(mng.create("SoundFileSource", "src"));
  net->addMarSystem(mng.create("AudioSink", "dest"));
	
  MarSystem* mainfanout = mng.create("Fanout", "mainfanout");
  net->addMarSystem(mainfanout);
  
  //
  // Create a series to make a windowed waveform for display
  //
  MarSystem* waveformnet = mng.create("Series", "waveformnet");
  mainfanout->addMarSystem(waveformnet);

  waveformnet->addMarSystem(mng.create("Windowing", "window"));
  waveformnet->addMarSystem(mng.create("Gain", "gain"));

  //
  // Create a series to do a stereo spectrum for display
  //
  MarSystem* spectrumnet = mng.create("Series", "spectrumnet");
  mainfanout->addMarSystem(spectrumnet);

  MarSystem* stereobranches = mng.create("Parallel", "stereobranches");
  MarSystem* left = mng.create("Series", "left");
  MarSystem* right = mng.create("Series", "right");

  left->addMarSystem(mng.create("Windowing", "hamleft"));
  left->addMarSystem(mng.create("Spectrum", "spkleft"));
  left->addMarSystem(mng.create("PowerSpectrum", "leftpspk"));
  left->addMarSystem(mng.create("Gain", "leftgain"));

  right->addMarSystem(mng.create("Windowing", "hamright"));
  right->addMarSystem(mng.create("Spectrum", "spkright"));
  right->addMarSystem(mng.create("PowerSpectrum", "rightpspk"));
  right->addMarSystem(mng.create("Gain", "rightgain"));

  stereobranches->addMarSystem(left);
  stereobranches->addMarSystem(right);

  spectrumnet->addMarSystem(stereobranches);
  spectrumnet->addMarSystem(mng.create("StereoSpectrum", "sspk"));

  net->updctrl("SoundFileSource/src/mrs_string/filename",inAudioFileName);
  net->updctrl("SoundFileSource/src/mrs_real/repetitions",-1.0);

  //net->updctrl("mrs_real/israte", 44100.0);
  net->updctrl("AudioSink/dest/mrs_bool/initAudio", true);


------------------------------ glwidget.cpp ------------------------------

** Fri Jun 19 2009 - 11:36:47 AM
   -----------------------------

Before changing the network to add statistics

#include <QtGui>
#include <QtOpenGL>
#include <QTimer>

#include <math.h>
#include <iostream>
#include <fstream>
#include <sstream>
using namespace std;

// Marsyas
#include "MarSystemManager.h"
#include "MarSystemQtWrapper.h"
using namespace MarsyasQt;

#include "glwidget.h"

GLWidget::GLWidget(string inAudioFileName, QWidget *parent)
  : QGLWidget(parent)
{
  // Initialize member variables
  xRot = 30;
  yRot = 0;
  zRot = 0;
  test_x = 0;
  test_y = 0;
  test_z = 0;
  
  // sness - Just creating this as 256 elements wide for simplicity,
  // but it should dynamically readjust to be the size of the window
  // from Marsyas.
  waveform_data.create(1,512);

  // Defaults
  rotation_speed = 10;
  y_scale = 350;

  

  // Allocate space for the ring buffer used to draw the spectrum
  spectrum_ring_buffer = new double*[MAX_SPECTRUM_LINES];
  for (int i = 0; i < MAX_SPECTRUM_LINES; i++) {
	spectrum_ring_buffer[i] = new double[SPECTRUM_SIZE];
	for (int j = 0; j < SPECTRUM_SIZE; j++) {
	  spectrum_ring_buffer[i][j] = 0.0;
	}
  }
  ring_buffer_pos = 0;
  
  //
  // Create the MarSystem to play and analyze the data
  // 
  MarSystemManager mng;

  MarSystem* net = mng.create("Series", "net");
  net->addMarSystem(mng.create("SoundFileSource", "src"));
  net->addMarSystem(mng.create("AudioSink", "dest"));
	
  MarSystem* stereobranches = mng.create("Parallel", "stereobranches");
  MarSystem* left = mng.create("Series", "left");
  MarSystem* right = mng.create("Series", "right");

  left->addMarSystem(mng.create("Windowing", "hamleft"));
  left->addMarSystem(mng.create("Spectrum", "spkleft"));
  left->addMarSystem(mng.create("PowerSpectrum", "leftpspk"));
  left->addMarSystem(mng.create("Gain", "leftgain"));

  right->addMarSystem(mng.create("Windowing", "hamright"));
  right->addMarSystem(mng.create("Spectrum", "spkright"));
  right->addMarSystem(mng.create("PowerSpectrum", "rightpspk"));
  right->addMarSystem(mng.create("Gain", "rightgain"));

  stereobranches->addMarSystem(left);
  stereobranches->addMarSystem(right);

  net->addMarSystem(stereobranches);
  net->addMarSystem(mng.create("StereoSpectrum", "sspk"));

  net->updctrl("SoundFileSource/src/mrs_string/filename",inAudioFileName);
  net->updctrl("SoundFileSource/src/mrs_real/repetitions",-1.0);

  //net->updctrl("mrs_real/israte", 44100.0);
  net->updctrl("AudioSink/dest/mrs_bool/initAudio", true);

  // Create and start playing the MarSystemQtWrapper that wraps
  // Marsyas in a Qt thread
  mwr_ = new MarSystemQtWrapper(net);
  mwr_->start();
  mwr_->play();

  //
  // Create the animation timer that periodically redraws the screen
  //
  QTimer *timer = new QTimer( this ); 
  connect( timer, SIGNAL(timeout()), this, SLOT(animate()) ); 
  timer->start(10); // Redraw the screen every 10ms
  
}

GLWidget::~GLWidget()
{
  makeCurrent();
}

// The minimum size of the widget
QSize GLWidget::minimumSizeHint() const
{
  return QSize(400, 400);
}

// The maximum size of the widget
QSize GLWidget::sizeHint() const
{
  return QSize(600, 600);
}

// Initialize the GL widget
void GLWidget::initializeGL()
{
  // Set the background color to white
  qglClearColor(Qt::black);

  // Set the shading model
  glShadeModel(GL_SMOOTH);
  
  // Enable depth testing
  glEnable(GL_DEPTH_TEST);

  // Enable fog for depth cueing
  GLfloat fogColor[4]= {0.0f, 0.0f, 0.0f, 1.0f};
  glClearColor(0.0f,0.0f,0.0f,1.0f);  // Fog colour of black (0,0,0)
  glFogfv(GL_FOG_COLOR, fogColor);    // Set fog color
  glFogi(GL_FOG_MODE, GL_EXP2);       // Set the fog mode
  glFogf(GL_FOG_DENSITY, 0.02f);      // How dense will the fog be
  glHint(GL_FOG_HINT, GL_NICEST);     // Fog hint value : GL_DONT_CARE, GL_NICEST
  glFogf(GL_FOG_START, 10.0f);          // Fog Start Depth
  glFogf(GL_FOG_END, 50.0f);            // Fog End Depth
  glEnable(GL_FOG);                   // Enable fog

  // Antialias lines
  glEnable(GL_LINE_SMOOTH);
  glHint (GL_LINE_SMOOTH_HINT,GL_NICEST);
}

// Paint the GL widget
void GLWidget::paintGL()
{
  // Clear the color and depth buffer
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
  // Load the identity matrix
  glLoadIdentity();

  // Translate the model to 0,0,-10
  glTranslated(0.0, 0.0, -29.0);

  // Rotate the object around the x,y,z axis
  glRotated(xRot / 16.0, 1.0, 0.0, 0.0);
  glRotated(yRot / 16.0, 0.0, 1.0, 0.0);
  glRotated(zRot / 16.0, 0.0, 0.0, 1.0);

  glTranslated(0.0, -0.75, -29.0);

  // Draw the object
  redrawScene();
  
  //    cout << "redrawing" << endl;
  //   mwr_->play();
  //   cout << mwr_->getctrl("mrs_realvec/processedData")->to<mrs_realvec>() << endl;


}

void GLWidget::animate() {
  //    cout << "animate" << endl;
  emit updateGL();
  addDataToRingBuffer();
  setWaveformData();
}

// Read in the waveform data from the waveformnet MarSystem
void GLWidget::setWaveformData() {
  waveform_data = mwr_->getctrl("Parallel/stereobranches/Series/left/Windowing/hamleft/mrs_realvec/processedData")->to<mrs_realvec>();
}

// Read in a line of data from the spectrumnet MarSystem
void GLWidget::addDataToRingBuffer() {
  mrs_realvec data = mwr_->getctrl("Parallel/stereobranches/Series/left/PowerSpectrum/leftpspk/mrs_realvec/processedData")->to<mrs_realvec>();

  for (int i = 0; i < SPECTRUM_SIZE; i++) {
	spectrum_ring_buffer[ring_buffer_pos][i] = data(i,0);
  }
  
  //   cout << "ring_buffer_pos=" << ring_buffer_pos << endl;

  ring_buffer_pos += 1;
  if (ring_buffer_pos >= MAX_SPECTRUM_LINES) {
	ring_buffer_pos = 0;
  }


}

void GLWidget::redrawScene() {

  glColor3f(1,1,1);
  renderText(20,20,"test");

  //
  // Draw the waveform
  //
   glColor3f(1,1,1);
   glBegin(GL_LINE_STRIP);
   for (int i = 0; i < 512; i++) {
	 float x = ((i - 256 / 2.0) / 200.0) - 0.7;
  	float y = (waveform_data(0,i)) + 2.5;
 	float z = 49;
// 	cout << "waveform : x=" << x << " y=" << y << endl;
 	glVertex3f(x,y,z);
   }
   glEnd();

  //
  // Draw the waterfall spectrum
  //
  for (int i = 0; i < MAX_SPECTRUM_LINES; i++) {
	glColor3f((i / (float)MAX_SPECTRUM_LINES),1,0); // A color ramp from yellow to green
	glBegin(GL_LINE_STRIP);
	for (int j = 0; j < SPECTRUM_SIZE; j++) {
	  float x = (j - SPECTRUM_SIZE / 2.0) / 40.0;
	  float y = y_scale * spectrum_ring_buffer[(i + ring_buffer_pos) % MAX_SPECTRUM_LINES][j];
 	  float z = i;
// 	  cout << "spectrum : x=" << x << " y=" << y << endl;
	  glVertex3f(x,y,z);
	}
	glEnd();
  }

}

// Resize the window
void GLWidget::resizeGL(int width, int height)
{
  // The smallest side of the window
  int side = qMin(width, height);

  // Setup the glViewport
  glViewport((width - side) / 2, (height - side) / 2, side, side);

  // Switch to GL_PROJECTION matrix mode
  glMatrixMode(GL_PROJECTION);

  // Load the identity matrix
  glLoadIdentity();

  // Setup an orthographic viewing system
  //   glOrtho(-2.0, +2.0, +2.0, -2.0, 4.0, 15.0);
  //   gluPerspective(30,1,0.1,1000);
  gluPerspective(20,1,0.1,1000);

  // Switch back to GL_MODELVIEW mode
  glMatrixMode(GL_MODELVIEW);
}

// Draw a face of the cube
void GLWidget::drawCubeFace(int a, int b, int c, int d) {
  // Start drawing the object
  glBegin(GL_POLYGON);

  // Draw the vertices of the cube
  glVertex3fv(vertices[a]);
  glVertex3fv(vertices[b]);
  glVertex3fv(vertices[c]);
  glVertex3fv(vertices[d]);

  // End drawing the object
  glEnd();
}

// Make the cube object
GLuint GLWidget::makeObject()
{
  // Make a new display list
  GLuint list = glGenLists(1);
  glNewList(list, GL_COMPILE);

  // Draw and color each face of the cube
  //   glColor3fv(colors[0]);
  //   draw_cube_face(0,3,2,1);
  //   glColor3fv(colors[2]);
  //   draw_cube_face(2,3,7,6);
  //   glColor3fv(colors[3]);
  //   draw_cube_face(3,0,4,7);
  //   glColor3fv(colors[1]);
  //   draw_cube_face(1,2,6,5);
  //   glColor3fv(colors[4]);
  //   draw_cube_face(4,5,6,7);
  //   glColor3fv(colors[5]);
  //   draw_cube_face(5,4,0,1);

  //   glColor3fv(colors[0]);
  //   glBegin(GL_TRIANGLES);
  //   for (int i = 0; i < 8; i++) {
  //  	glVertex3f(vertices[i][0]+0.0,vertices[i][1]+0.0,vertices[i][2]+0.0);
  // 	glVertex3f(vertices[i][0]+0.05,vertices[i][1]+0.05,vertices[i][2]+0.0);
  // 	glVertex3f(vertices[i][0]+0.05,vertices[i][1]-0.05,vertices[i][2]+0.0);
  //   }
  //   glEnd();

  

  glEndList();
  return list;
}

// Normalize an angle
void GLWidget::normalizeAngle(int *angle)
{
  while (*angle < 0)
	*angle += 360 * 16;
  while (*angle > 360 * 16)
	*angle -= 360 * 16;
}

// // Set the end x rotation value
// void GLWidget::setEndXRotation(int angle)
// {
//   normalizeAngle(&angle);
//   end_xRot = angle;
// }

// // Set the end y rotation value
// void GLWidget::setEndYRotation(int angle)
// {
//   normalizeAngle(&angle);
//   end_yRot = angle;
// }

// // Set the end z rotation value
// void GLWidget::setEndZRotation(int angle)
// {
//   normalizeAngle(&angle);
//   end_zRot = angle;
// }

// // Start the animation timer
// void GLWidget::startTimerRotate()
// {
//   // If we are already doing an animation, just return
//   if (timer->isActive())
// 	return;

//   // Start the timer, with the timeout of the timer being the rotation
//   // speed
//   timer->start(rotation_speed);

//   // Initialize the counter for how many steps we are through the
//   // animation
//   timerCount = 0;
// }

// // Do one click of the animation timer
// void GLWidget::doTimerRotate() 
// {
//   // Increment the animation steps
//   ++timerCount;

//   // If we've done the required number of steps, stop the animation timer
//   if (timerCount >= TIMER_COUNT_STEPS)
// 	timer->stop();

//   // Emit a signal to say that the number of animation steps has changed
//   emit timerChanged(timerCount);

//   // Linearly interpolate the values for the x,y,z rotation values and
//   // emit signals for them
//   int x = start_xRot + ((timerCount / TIMER_COUNT_STEPS) * end_xRot);
//   int y = start_yRot + ((timerCount / TIMER_COUNT_STEPS) * end_yRot);
//   int z = start_zRot + ((timerCount / TIMER_COUNT_STEPS) * end_zRot);

//   // Set the x,y,z rotation angles
//   setXRotation(x);
//   setYRotation(y);
//   setZRotation(z);

// }

// // Set the rotation speed
// void GLWidget::setRotationSpeed(int speed)
// {
//   rotation_speed = speed;
// }



// void GLWidget::playSong() {
// }

// Set the test z rotation value
void GLWidget::setYScale(int scale)
{
  y_scale = scale;
  cout << "y_scale=" << y_scale << endl;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


// Set the x rotation angle
void GLWidget::setXRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != xRot) {
	xRot = angle;
	emit xRotationChanged(angle);
	updateGL();
  }
}

// Set the y rotation angle
void GLWidget::setYRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != yRot) {
	yRot = angle;
	emit yRotationChanged(angle);
	updateGL();
  }
}

// Set the z rotation angle
void GLWidget::setZRotation(int angle)
{
  normalizeAngle(&angle);
  if (angle != zRot) {
	zRot = angle;
	emit zRotationChanged(angle);
	updateGL();
  }
}


// Set the test x rotation value
void GLWidget::setTestX(int val)
{
  //   test_x = 5 - (val / 10);
  test_x = 5.0 - (val / 20.0);
  cout << "x :: val=" << val << " x=" << test_x << endl;
}

// Set the test y rotation value
void GLWidget::setTestY(int val)
{
  test_y = 5.0 - (val / 20.0);
  cout << "y :: val=" << val << " y=" << test_y << endl;
}

// Set the test z rotation value
void GLWidget::setTestZ(int val)
{
  test_z = val;
  cout << "z :: val=" << val << " z=" << test_z << endl;
}


------------------------------ glwidget.cpp ------------------------------

  //
  // Create the MarSystem to play and analyze the data
  // 
  MarSystemManager mng;

  MarSystem* net = mng.create("Series", "net");
  net->addMarSystem(mng.create("SoundFileSource", "src"));
  net->addMarSystem(mng.create("AudioSink", "dest"));
	
  MarSystem* stereobranches = mng.create("Parallel", "stereobranches");
  MarSystem* left = mng.create("Series", "left");
  MarSystem* right = mng.create("Series", "right");

  left->addMarSystem(mng.create("Windowing", "hamleft"));
  left->addMarSystem(mng.create("Spectrum", "spkleft"));
  left->addMarSystem(mng.create("PowerSpectrum", "leftpspk"));
  left->addMarSystem(mng.create("Gain", "leftgain"));

  right->addMarSystem(mng.create("Windowing", "hamright"));
  right->addMarSystem(mng.create("Spectrum", "spkright"));
  right->addMarSystem(mng.create("PowerSpectrum", "rightpspk"));
  right->addMarSystem(mng.create("Gain", "rightgain"));

  stereobranches->addMarSystem(left);
  stereobranches->addMarSystem(right);

  net->addMarSystem(stereobranches);
  net->addMarSystem(mng.create("StereoSpectrum", "sspk"));

  net->updctrl("SoundFileSource/src/mrs_string/filename",inAudioFileName);
  net->updctrl("SoundFileSource/src/mrs_real/repetitions",-1.0);


------------------------------ glwidget.cpp ------------------------------

GLWidget::GLWidget(string inAudioFileName, QWidget *parent)
  : QGLWidget(parent)
{
  // Initialize member variables
  xRot = 30;
  yRot = 0;
  zRot = 0;
  test_x = 0;
  test_y = 0;
  test_z = 0;
  
  // sness - Just creating this as 256 elements wide for simplicity,
  // but it should dynamically readjust to be the size of the window
  // from Marsyas.
  waveform_data.create(1,512);

  // Defaults
  rotation_speed = 10;
  y_scale = 350;

  

  // Allocate space for the ring buffer used to draw the spectrum
  spectrum_ring_buffer = new double*[MAX_SPECTRUM_LINES];
  for (int i = 0; i < MAX_SPECTRUM_LINES; i++) {
	spectrum_ring_buffer[i] = new double[SPECTRUM_SIZE];
	for (int j = 0; j < SPECTRUM_SIZE; j++) {
	  spectrum_ring_buffer[i][j] = 0.0;
	}
  }
  ring_buffer_pos = 0;
  
  //
  // Create the MarSystem to play and analyze the data
  // 
  MarSystemManager mng;

  MarSystem* net = mng.create("Series", "net");


  // A Fanout to let us read audio from either a SoundFileSource or an
  // AudioSource
  MarSystem* inputfanout = mng.create("Fanout", "inputfanout");
  net->addMarSystem(inputfanout);

//   inputfanout->addMarSystem(mng.create("SoundFileSource", "src"));
  inputfanout->addMarSystem(mng.create("AudioSource", "src"));

//   net->addMarSystem(mng.create("Selector", "inputselector"));

//   if (inAudioFileName == "") {
// 	net->updctrl("Selector/inputselector/mrs_natural/enable", 0);
// 	net->updctrl("Selector/inputselector/mrs_natural/enable", 1);
// 	cout << "input from AudioSource" << endl;
//   } else {
// 	net->updctrl("Selector/inputselector/mrs_natural/enable", 1);
// 	net->updctrl("Selector/inputselector/mrs_natural/enable", 0);
// 	cout << "input from SoundFileSource" << endl;
//   }

  // Add the AudioSink right after we've selected the input and
  // before we've calculated any features.  Nice trick.
//   net->addMarSystem(mng.create("AudioSink", "dest"));
  net->addMarSystem(mng.create("Stereo2Mono", "stereo2mono"));
	
  net->addMarSystem(mng.create("Windowing", "ham"));
  net->addMarSystem(mng.create("Spectrum", "spk"));
  net->addMarSystem(mng.create("PowerSpectrum", "pspk"));
  net->addMarSystem(mng.create("Gain", "gain"));

  MarSystem* spectrumFeatures = mng.create("Fanout", "spectrumFeatures");
  spectrumFeatures->addMarSystem(mng.create("Centroid", "cntrd"));
  spectrumFeatures->addMarSystem(mng.create("Rolloff", "rlf"));      
  spectrumFeatures->addMarSystem(mng.create("Flux", "flux"));
  spectrumFeatures->addMarSystem(mng.create("Rms", "rms"));
  net->addMarSystem(spectrumFeatures);

  // Set the controls of this MarSystem
  
//   net->updctrl("Fanout/inputfanout/SoundFileSource/src/mrs_real/repetitions",-1.0);

  net->updctrl("mrs_real/israte", 44100.0);
  inputfanout->updctrl("AudioSource/src/mrs_bool/initAudio", true);

//   if (inAudioFileName != "") {
// 	net->updctrl("Fanout/inputfanout/SoundFileSource/src/mrs_string/filename",inAudioFileName);
// 	net->updctrl("AudioSink/dest/mrs_bool/initAudio", true);
//   }

  // Create and start playing the MarSystemQtWrapper that wraps
  // Marsyas in a Qt thread
  mwr_ = new MarSystemQtWrapper(net);
  mwr_->start();
//   play_state = false;

  mwr_->play();
  play_state = true;
  
  // Create some handy pointers to access the MarSystem
  posPtr_ = mwr_->getctrl("Fanout/inputfanout/SoundFileSource/src/mrs_natural/pos");
  initPtr_ = mwr_->getctrl("AudioSink/dest/mrs_bool/initAudio");
  fnamePtr_ = mwr_->getctrl("Fanout/inputfanout/SoundFileSource/src/mrs_string/filename");

  //
  // Create the animation timer that periodically redraws the screen
  //
  QTimer *timer = new QTimer( this ); 
  connect( timer, SIGNAL(timeout()), this, SLOT(animate()) ); 
  timer->start(10); // Redraw the screen every 10ms
  
}
